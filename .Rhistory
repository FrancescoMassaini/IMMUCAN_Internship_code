name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
View(metagene_df_combined)
View(metagene_df_NSCLC)
View(metasample_df_combined)
# Chunk 1: Imports
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
# Chunk 2: Functions
source("./Functions.R")
setwd("/home/francesco.massaini/Desktop/")
setwd("/home/francesco.massaini/Desktop/IMMUCAN_Internship_code/")
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
#write.table(TPM_forDeconv, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt", sep = "\t")
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
#write.table(TPM_forDeconv, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt", sep = "\t")
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_filtered_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 12, zero_count_percent_threshold = 0.8)
compute_distribution(data = merged_counts_filtered_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_filtered_forClustering_gene_symbol <- merged_counts_filtered_forClustering %>%
EnsemblID_to_GeneSymbol(., aggregation_method = "mean") # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_filtered_forClustering <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.2)
cat("Number of final genes:", nrow(TPM_filtered_forClustering), "\n Number of starting genes:",  nrow(merged_counts), "\n Difference:", nrow(merged_counts)-nrow(TPM_filtered_forClustering))
compute_distribution(data = TPM_filtered_forClustering, plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
TPM_filtered_forClustering = log2(TPM_filtered_forClustering+1)
colSums(TPM_filtered_forClustering)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, side_localization, gender) %>%
column_to_rownames(var = "immucan_id")
# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical = TPM_filtered_forClustering
colnames(TPM_formatted_for_clinical) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_formatted_for_clinical))
common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical))
TPM_formatted_for_clinical <- TPM_formatted_for_clinical %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Save the file in the right format for BIODICA INDIPENDENT COMPONENT ANALYSIS (IDA)
TPM_forBIODICA = TPM_formatted_for_clinical %>%
rownames_to_column(var = "genes")
# write.table(TPM_forBIODICA, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica_meanDuplGenes.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
# Ensure to merge in the same order TPM and clinical values and traspose
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
replace(is.na(.), "NA") # Replace NA with missing to show NA values on fviz_pca_biplot
# Compute PCA
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(TPM_formatted_for_clinical, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
TPM_formatted_for_clinical = as.data.frame(t(TPM_formatted_for_clinical))
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, side_localization, gender) %>%
column_to_rownames(var = "immucan_id")
# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Show results
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = TRUE,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
border = NA)
# Select most important ICs
chosen_IC = c("IC1", "IC8", "IC14", "IC4", "IC13", "IC16", "IC3")
metasample_df_selected <- metasample_df[chosen_IC, , drop = FALSE]
# Plot final SAMPLE heatmap
pheatmap(metasample_df_selected, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = TRUE,
cluster_rows = TRUE,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
border = NA)
# Prepare the data
# Convert 'metasample_df' into a long format
long_metasample <- as.data.frame(t(metasample_df)) %>%
tibble::rownames_to_column("Sample") %>%
pivot_longer(-Sample, names_to = "IC", values_to = "Value")
# Generate violin plots for each IC for each clinical variable
clinical_vars = colnames(clinical) # List of clinical variables
ICs = unique(long_metasample$IC)
# Aggregate violin plot for each clinical variable
for (clin_var in clinical_vars) {
Wrapped_violin_plot_by_clinical_feature(df_long = long_metasample, metadata_df = clinical, metadata_var = clin_var, facet_wrap_var = "IC")
}
# Specific significant violin plot
for (clin_var in clinical_vars) {
for (IC_value in ICs){
df = long_metasample %>%
dplyr::filter(IC == IC_value) %>%
dplyr::select(Sample, IC, Value)
significant_violin_plot(df_long = df, metadata_df = clinical, metadata_var = clin_var, p_threshold = 0.05, main_title = paste("Significant violin plot for", IC_value))
}
}
# ADImpute to normalize to TPM
TPM_high_variance_genes <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.75)
cat("Final nomber of genes: ", nrow(TPM_high_variance_genes))
compute_distribution(data = TPM_high_variance_genes, plot_title = "Distribution of high variance genes - TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
# Finally convert TPM to log2(TPM+1)
TPM_high_variance_genes = log2(TPM_high_variance_genes+1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, gender, simple_histology) %>%
column_to_rownames(var = "immucan_id")
# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical_high_variance = TPM_high_variance_genes
colnames(TPM_formatted_for_clinical_high_variance) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_formatted_for_clinical_high_variance))
common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical_high_variance))
TPM_formatted_for_clinical_high_variance <- TPM_formatted_for_clinical_high_variance %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical_high_variance,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Save the file in the right format for BIODICA INDIPENDENT COMPONENT ANALYSIS (IDA)
TPM_forBIODICA = TPM_formatted_for_clinical_high_variance %>%
rownames_to_column(var = "genes")
# write.table(TPM_forBIODICA, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical_high_variance,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
# Ensure to merge in the same order TPM and clinical values and traspose
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical_high_variance, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical_high_variance = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
replace(is.na(.), "NA") # Replace NA with missing to show NA values on fviz_pca_biplot
# Compute PCA
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical_high_variance, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(TPM_formatted_for_clinical_high_variance, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
TPM_formatted_for_clinical_high_variance = as.data.frame(t(TPM_formatted_for_clinical_high_variance))
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Show results
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = TRUE,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
border = NA)
# Select most important ICs
chosen_IC = c("IC1", "IC2", "IC3", "IC9", "IC14", "IC11", "IC22")
metasample_df_selected <- metasample_df[chosen_IC, , drop = FALSE]
# Plot final SAMPLE heatmap
pheatmap(metasample_df_selected, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = TRUE,
cluster_rows = TRUE,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
border = NA)
# Prepare the data
# Convert into a long format
long_metasample <- as.data.frame(t(metasample_df_selected)) %>%
tibble::rownames_to_column("Sample") %>%
pivot_longer(-Sample, names_to = "IC", values_to = "Value")
# Generate violin plots for each IC for each clinical variable
clinical_vars = colnames(clinical) # List of clinical variables
ICs = unique(long_metasample$IC)
# Aggregate violin plot for each clinical variable
for (clin_var in clinical_vars) {
Wrapped_violin_plot_by_clinical_feature(df_long = long_metasample, metadata_df = clinical, metadata_var = clin_var, facet_wrap_var = "IC")
}
# Specific significant violin plot
for (clin_var in clinical_vars) {
for (IC_value in ICs){
df = long_metasample %>%
dplyr::filter(IC == IC_value) %>%
dplyr::select(Sample, IC, Value)
significant_violin_plot(df_long = df, metadata_df = clinical, metadata_var = clin_var, p_threshold = 0.05, main_title = paste("Significant violin plot for", IC_value))
}
}
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, side_localization, gender) %>%
column_to_rownames(var = "immucan_id")
# Loading Deconvolution results
deconv <- read.table("../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/all_deconvolutions_NSCLC2_TPM_withoutCD226_withoutPatient3.txt", header = TRUE,  sep = '	', row.names = 1)
rownames(deconv) = gsub(pattern = "-FIXT.*",
replacement = "",
x = rownames(deconv))
# Only common patients
common_samples <- intersect(rownames(clinical), rownames(deconv))
deconv <- deconv[common_samples,]
clinical = clinical[common_samples,]
# Ensure same patients order
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(t(deconv),  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(t(deconv),  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
# Ensure to merge in the same order TPM and clinical values and traspose
tmp = dfs_same_patients_same_order(t(deconv), clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
deconv = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
replace(is.na(.), "NA") # Replace NA with missing to show NA values on fviz_pca_biplot
# Compute PCA
pca_result <- FactoMineR::PCA(deconv, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(deconv, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Correlation
create_correlation_plot(data1 = deconv, data2 = metasample_df, correlation_type = "pearson", r_threshold = 0.7, p_threshold = 0.05)
