---
title: "Analysis"
author: "Francesco Massaini"
date: "2024-03-26"
output: html_document
---

```{r}
source("src/environment_set.R")
```

Input files
```{r}
# Load clinical
traitData = read.csv("../../../Desktop/IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_Daniel_relevant_columns.csv", row.names = 1)


# Compute deconvolution
# TPM = read.delim("../../../Desktop/IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM_forDeconv.txt", sep = "\t", check.names = FALSE)
# 
# deconv_CellTFusion = compute.deconvolution(TPM_matrix = TPM, signatures_exclude = "CD226", credentials.mail = "marcelo.hurtado@inserm.fr", credentials.token = "734212f6ad77fc4eea2bdb502792f294")
# deconv_CellTFusion = as.data.frame(deconv_CellTFusion)

# write.table(deconv_CellTFusion ,"../../../Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/NSCLC2_deconvolution_fromCellTFusion.txt", sep = "\t")

# Load previously computed deconvolution
deconv = read.delim("../../../Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/NSCLC2_deconvolution_fromCellTFusion.txt", sep = "\t", check.names = FALSE)
rownames(deconv) <- sub("-FIXT.*", "", rownames(deconv))

common_patients <- intersect(rownames(traitData), rownames(deconv))

deconv = deconv[common_patients,]
traitData = traitData[common_patients,]

counts.norm = read.delim("../../../Desktop/IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM_forDeconv.txt", row.names = 1, check.names = FALSE) 
colnames(counts.norm) <- sub("-FIXT.*", "", colnames(counts.norm))

counts.norm = counts.norm[,common_patients]

# imagingIF = read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/all_IFs_cell_type_fraction.csv", row.names = 1)
# rownames(imagingIF) <- str_remove_all(string = rownames(imagingIF), pattern = "-RNA-01|-RNA-02|-RNA-04|-FIXT-01")
# common_patients = intersect(rownames(imagingIF), rownames(deconv))

```

CellTFusion

1. TFs inference
```{r}
tfs = compute.TFs.activity(counts.norm)
save(tfs, file = "../../../Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_tfs_NSCLC2.RData")
```

2. TFs network construction
Group meeting 31/10/2023 slide 27. All the pass
corr_mod value from 0 to 1 used for merge modules in a second
iteration. After the first TF-module construction, a correlation
will take place between modules and modules correlated by a
threshold higher than this value will be merged. Default value
is 0.8. Simile a quello che si fa con le features alla fine 
```{r}
network = compute.WTCNA(tfs, corr_mod = 0.8, clustering.method = "ward.D2") # Soft_Threshold file is in usr_projects/Results

# Association of TFs modules with clinical data
compute.metada.association(network[[1]], traitData, pval = 0.05, width = 10) 
```

3. Modules characterization
Questioni relative all'enrichment. I moduli sono costituiti da TFs ma se fai l'arricchimento di questi geni rispetto ad un universo che e' tutti i geni, ottieni come risultato l-arricchimento in "Regolazione genica". 
Per evitare cio' e ottenere l'arricchimento in cosa fanno effettivamente i moduli, quello che fai e' prendere i geni regolati da questi TF (e la funzione compute.modules.enrichment prima estrae questi geni dal totale dei dati) e fare l-arricchimento di questi target genes contro l'universo di tutti i geni. 
In alternativa potresti ridurre l'universo a tutti i TF possibili e vedere se questi sono arricchiti. Se pero' riduci l'universo ci sono dei problemi statistici.

To avoid common enrichment results
because of the overlapping of several target genes, a step to filter and only keep unique pathways by
module is done.

```{r}
# Probably tfs used to extract tf and found all the genes. network[[1]] e' la matrice con tutti i moduli per i vari samples e network[[2]] e' una lista di caratteri che corrispondono a quale TF corrisponde a quele modulo
#library(enrichplot) 
compute.modules.enrichment(counts.norm, tfs, network[[1]], network[[2]])
```

4. Pathways activity inference
```{r}
# Additional characterization of TFs modules is done by performing a Gene Set Variation Analysis (GSVA) using Progeny and Hallmarks signatures from MsigDB.

pathways = compute.pathway.activity(counts.norm)
#Association of TFs modules with pathways
compute.modules.relationship(network[[1]], pathways, "Pathways_Progeny-TFs_Modules", width = 15)
```

5. Deconvolution analysis
The function computes linear and proportional correlations to produce cell subgroups of methods and
signatures correlated for above a specific threshold within each cell type.
```{r}
deconvolution = fix.names.GEMDeCan(deconv)
dt = compute.deconvolution.analysis(deconvolution, corr = 0.7, seed = 123)
save(dt, file = "../../../Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_Subgroups_NSCLC2.RData")
#Association of TFs modules with deconvolution 
compute.modules.relationship(network[[1]], dt[[1]], "Deconvolution-TFs_Modules", vertical = T, height = 30, width = 10, pval = 0.05)
```


```{r}
features = compute.modules.relationship(network[[1]], dt[[1]], return = T)
cell_dendrograms = identify.cell.groups(features[[1]], features[[2]], height = 20) 

save(features, file = "../../../Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_modules_deconv_NSCLC2.RData")

```

8. Cell groups analysis
Compute on adjuvant treatment
```{r}
res = cell.groups.analysis(dt[[1]], coldata = traitData, trait = "adjuvant_treatment", cell.dendrograms = cell_dendrograms, cut.height = 2, stat.test = 'Anova', pval = 0.07, height = 20)
#res2 = cell.groups.analysis(dt[[1]], coldata = traitData, trait = "adjuvant_treatment", cell.dendrograms = cell_dendrograms, cut.height = 2, stat.test = 'Fisher', pval = 0.07, height = 20)
res_TIL = cell.groups.analysis(dt[[1]], coldata = traitData, trait = "TIL_score", cell.dendrograms = cell_dendrograms, cut.height = 1, stat.test = 'Anova', pval = 0.07, height = 20)
res_gender = cell.groups.analysis(dt[[1]], coldata = traitData, trait = "gender", cell.dendrograms = cell_dendrograms, cut.height = 1, stat.test = 'Anova', pval = 0.07, height = 20)
# SET HEIGHT (see vignette)
```

```{r}
res_all = cell.groups.analysis(dt[[1]], cell.dendrograms = cell_dendrograms, cut.height = 0.7, height = 20)
head(res_all[[1]][,1:3])
```



9. Machine Learning analysis
```{r}
prediction_anova = compute.ML.models(res[[1]], traitData, "adjuvant_treatment", "Yes", partition = 0.7, k_folds = 5, n_rep = 20, file_name = "ML_Adj_treatment", train_iterations = 30, predict_iterations = 30)
prediction_anova_TIL = compute.ML.models(res_TIL[[1]], traitData, "TIL_score", "Severe", partition = 0.7, k_folds = 5, n_rep = 20, file_name = "ML_TIL_score", train_iterations = 30, predict_iterations = 30)
```

```{r}
prediction_Boruta = compute.ML.models(res_all[[1]], traitData, "adjuvant_treatment", "Yes", partition = 0.8, k_folds = 10, n_rep = 10, file_name = "Tutorial_Boruta", train_iterations = 30, predict_iterations = 30, boruta = T, rough_fix = T, tentative = F)
```

```{r}
save(res, prediction_Boruta, file = "results.RData")
```

