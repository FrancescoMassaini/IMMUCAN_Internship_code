ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
prova <- remove_after_dot(gexp_tpm)
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
prova <- remove_after_dot(gexp_tpm)
View(prova)
View(gexp_tpm)
rownames(gexp_tpm) %>%
str_remove(.,"\\..*$")
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
new_rownames <- rownames(TPM) %>%
str_remove(.,"\\..*$")
rownames(TPM) <- new_rownames
return(TPM)
}
# Replace ENSEMBL ID with GENE SYMBOL
ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
prova <- remove_after_dot(gexp_tpm)
a <- rownames(gexp_tpm) %>%
str_remove(.,"\\..*$")
rownames(gexp_tpm) <- a
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
a <- rownames(gexp_tpm) %>%
str_remove(.,"\\..*$")
rownames(gexp_tpm) <- a
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
rownames(TPM) <- rownames(TPM) %>%
str_remove("\\..*$")
return(TPM)
}
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
prova <- remove_after_dot(gexp_tpm)
a <- rownames(gexp_tpm) %>%
str_remove(.,"\\..*$")
rownames(gexp_tpm) <- a
BC2_gene_symbols <- ID_to_GENE_SYMBOL(gexp_tpm)
prova <- remove_after_dot(gexp_tpm)
View(prova)
BC2_TPM <- remove_after_dot(gexp_tpm)
View(BC2_TPM)
str(BC2_TPM)
class(BC2_TPM)
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
rownames(TPM) <- rownames(TPM) %>%
str_remove("\\..*$")
return(as.data.frame(TPM))
}
# Replace ENSEMBL ID with GENE SYMBOL
ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
BC2_TPM <- remove_after_dot(gexp_tpm)
View(BC2_TPM)
BC2_gene_symbols <- ID_to_GENE_SYMBOL(BC2_TPM)
library(dplyr)
library(tibble)
library(org.Hs.eg.db) # Homo sapiens db
library(stringr)
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
rownames(TPM) <- rownames(TPM) %>%
str_remove("\\..*$")
return(as.data.frame(TPM))
}
# Replace ENSEMBL ID with GENE SYMBOL
ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
BC2_TPM <- remove_after_dot(gexp_tpm)
BC2_gene_symbols <- ID_to_GENE_SYMBOL(BC2_TPM)
View(BC2_gene_symbols)
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE,  sep = '	', row.names = 1)
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE,  sep = '	', row.names = 1)
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list)
colnames(BC2_gene_symbols)
samples_list
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE,  sep = '	', row.names = 1)
samples_list
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
samples_list <- read_tsv("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv")
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv")
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE, sep = "\t")
View(samples_list)
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list)
samples_list
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list$sample)
BC2_samples
length(BC2_samples)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tibble)
library(org.Hs.eg.db) # Homo sapiens db
library(stringr)
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
rownames(TPM) <- rownames(TPM) %>%
str_remove("\\..*$")
return(as.data.frame(TPM))
}
# Replace ENSEMBL ID with GENE SYMBOL
ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
BC2 <- load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE, sep = "\t")
BC2_TPM <- remove_after_dot(gexp_tpm)
BC2_gene_symbols <- ID_to_GENE_SYMBOL(BC2_TPM)
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list$sample)
length(BC2_samples)
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE, sep = "\t")
View(samples_list)
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list$sample)
BC2_samples
# Deleting (not)duplicated file to avoid problems with QuanTIseq
library(tidyverse)
library(dplyr)
# path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC1/02_TPM/BC1_TPM_Mounim.txt",
"/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_Mounim.txt",
# Deleting (not)duplicated file to avoid problems with QuanTIseq
library(tidyverse)
library(dplyr)
# path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC1/02_TPM/BC1_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/BC3/02_TPM/BC3_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC/02_TPM/NSCLC_TPM_Mounim.txt")
path <- ("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_fromRdata.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
TPM <- TPM[rownames(TPM)%in%rownames(immunedeconv::dataset_racle$expr_mat),] %>%
rownames_to_column("Genes")
write.table(TPM, file = paste0("/home/francesco.massaini/Desktop/IMMUCAN_data/", folders_names[[i]][1], "/02_TPM/", files_names[i],"_genes_filtered_for_Quantiseq.txt"), quote = F, sep = "\t", row.names = F)
}
knitr::opts_chunk$set(echo = TRUE)
load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
names(gexp_tpm)
colnames(gexp_tpm)
"IMMU-BC2-0871-FIXT-01" %in% colnames(gexp_tpm)
"IMMU-BC2-0876-FIXT-01" %in% colnames(gexp_tpm)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tibble)
library(org.Hs.eg.db) # Homo sapiens db
library(stringr)
# Remove version number from ENSEMBL ID
remove_after_dot <- function(TPM) {
rownames(TPM) <- rownames(TPM) %>%
str_remove("\\..*$")
return(as.data.frame(TPM))
}
# Replace ENSEMBL ID with GENE SYMBOL
ID_to_GENE_SYMBOL <- function(TPM){
entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(TPM), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your TPM
TPM <- TPM %>%
mutate(ENSEMBL = rownames(TPM)) %>% # add a column
inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
dplyr::filter(!is.na(SYMBOL)) %>%
distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
column_to_rownames("SYMBOL") %>%
dplyr::select(., -c("ENSEMBL"))
}
load("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_estimated_TPM.RData")
samples_list <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/Patient_to_include_from_rna_samples_bc2_to_create_custom_cohort.tsv", header = TRUE, sep = "\t")
BC2_TPM <- remove_after_dot(gexp_tpm)
BC2_gene_symbols <- ID_to_GENE_SYMBOL(BC2_TPM)
BC2_samples <- intersect(colnames(BC2_gene_symbols), samples_list$sample)
BC2 <- BC2_gene_symbols[BC2_samples] %>%
rownames_to_column("Genes")
write.table(BC2, file = "/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_fromRdata.txt", quote = F, sep = "\t", row.names = F)
library(tidyverse)
library(dplyr)
# path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC1/02_TPM/BC1_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/BC3/02_TPM/BC3_TPM_Mounim.txt",
#                "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC/02_TPM/NSCLC_TPM_Mounim.txt")
path <- ("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_TPM_fromRdata.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
TPM <- TPM[rownames(TPM)%in%rownames(immunedeconv::dataset_racle$expr_mat),] %>%
rownames_to_column("Genes")
write.table(TPM, file = paste0("/home/francesco.massaini/Desktop/IMMUCAN_data/", folders_names[[i]][1], "/02_TPM/", files_names[i],"_genes_filtered_for_Quantiseq.txt"), quote = F, sep = "\t", row.names = F)
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
# library(org.Hs.eg.db) # Homo sapiens db
# columns(org.Hs.eg.db) # to look at the columns of this db
# Plots - Heatmap
TPM_Heatmap <- function(TPM){
TPM <- as.matrix(TPM)
# Utilizes the NormalizeTPM function from the ADImpute package.
# Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
# Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
# This is often employed to reduce variance and approximate a normal distribution.
# Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
sampleDists <- dist(t(TPM)) #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,    main = "Sample clustering to detect outliers", sub="", xlab="",
cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Plots - Dendrogram
TPM_Sample_dendrogram <- function(TPM){
sampleTree = hclust(dist(t(TPM)), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Data Loading
path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_filtered_samples.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
# EDA
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
pdf(paste0("../IMMUCAN_data/", folders_names[[i]][1], "/02_Plot_Outliers/", files_names[i],"_outliers"), width = 16) # folders_names[[i]][1] double square bracket to access to the i vector, single bracket to access to the first value of the i vector
TPM_Heatmap(TPM)
TPM_Sample_dendrogram(TPM)
dev.off()
}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(stringr)
library(dplyr)
# Plots by methods showing cell proportions across samples
plot_by_method <- function(selected_method, result_file) {
final_df = data.frame()
for (i in 1:nrow(result_file)) {
tmp = data.frame("Samples" = rownames(result_file)[i],
"Cells" = colnames(result_file),
"Prop" = as.vector(t(result_file[i,])))
final_df = rbind(final_df, tmp)
}
plot = ggplot(final_df) +
ggtitle(selected_method) +
geom_bar(aes(x=Samples, y = Prop, fill= Cells), stat = "identity") + #specify only the NAMES of columns. Data are collected from ggplot(final_df)
# By default, the axes are aligned at the center of the text, even when rotated. When you rotate +/- 90 degrees, you usually want it to be aligned at the edge instead:
# vjust = 0.5 allinea il testo a meta della linea in cui deve stare il label dal punto di vista verticale
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5),
legend.text = element_text(size = 5))
print(plot)
}
# Data Loading
path <- "/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/all_deconvolutions_BC2_filtered_samples.txt"
data <- read.table(path, header = TRUE, sep = "\t", row.names = 1)
fixed_methods <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/fixed_methods.txt", header = FALSE, sep = "\t")
variable_methods <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/variable_methods.txt", header = FALSE, sep = "\t")
empty_pos <-  which(variable_methods[,1] == "", arr.ind = TRUE) # Clean empty pos
variable_methods_list <- variable_methods[-empty_pos,1]
# Keep only methods with variable signature
# Store signature
all_ms <- fixed_methods[,1] # Store in a list all the combinations of methods and signatures
for (i in variable_methods_list) {
# print(paste("i", i))
for (j in variable_methods[,2]){
# print(paste("j", j))
tmp <- paste(i,j, sep = "_")
# append(all_ms, tmp) doesn't work
all_ms <- c(all_ms, tmp)
# print(paste("tmp", tmp))
}
}
# More details https://r-graph-gallery.com/48-grouped-barplot-with-ggplot2
pdf("Results")
for (i in all_ms) {
print(i)
selected_method_data <- data[rownames(data), grep(i, colnames(data))]
plot_by_method(selected_method = i, result_file = selected_method_data)
}
dev.off()
# problem quando grep cerca BPRNACan trova anche BPRNACanPro(met) e BPRNACanProMet quindi nei risultati viene sommato tutto quanto perche si costruisce una tabella con anche le colonne di questi metodi con signature diverse. Provare con un if per escludere proprio i casi sbagliati (in BPRNACan)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(stringr)
library(dplyr)
# Plots by methods showing cell proportions across samples
plot_by_method <- function(selected_method, result_file) {
final_df = data.frame()
for (i in 1:nrow(result_file)) {
tmp = data.frame("Samples" = rownames(result_file)[i],
"Cells" = colnames(result_file),
"Prop" = as.vector(t(result_file[i,])))
final_df = rbind(final_df, tmp)
}
plot = ggplot(final_df) +
ggtitle(selected_method) +
geom_bar(aes(x=Samples, y = Prop, fill= Cells), stat = "identity") + #specify only the NAMES of columns. Data are collected from ggplot(final_df)
# By default, the axes are aligned at the center of the text, even when rotated. When you rotate +/- 90 degrees, you usually want it to be aligned at the edge instead:
# vjust = 0.5 allinea il testo a meta della linea in cui deve stare il label dal punto di vista verticale
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 5),
legend.text = element_text(size = 5))
print(plot)
}
# Data Loading
path <- "/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/all_deconvolutions_BC2_filtered_samples.txt"
data <- read.table(path, header = TRUE, sep = "\t", row.names = 1)
fixed_methods <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/fixed_methods.txt", header = FALSE, sep = "\t")
variable_methods <- read.table("/home/francesco.massaini/Desktop/IMMUCAN_data/variable_methods.txt", header = FALSE, sep = "\t")
empty_pos <-  which(variable_methods[,1] == "", arr.ind = TRUE) # Clean empty pos
variable_methods_list <- variable_methods[-empty_pos,1]
# Keep only methods with variable signature
# Store signature
all_ms <- fixed_methods[,1] # Store in a list all the combinations of methods and signatures
for (i in variable_methods_list) {
# print(paste("i", i))
for (j in variable_methods[,2]){
# print(paste("j", j))
tmp <- paste(i,j, sep = "_")
# append(all_ms, tmp) doesn't work
all_ms <- c(all_ms, tmp)
# print(paste("tmp", tmp))
}
}
# More details https://r-graph-gallery.com/48-grouped-barplot-with-ggplot2
pdf("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/Methods_Results")
for (i in all_ms) {
print(i)
selected_method_data <- data[rownames(data), grep(i, colnames(data))]
plot_by_method(selected_method = i, result_file = selected_method_data)
}
dev.off()
# problem quando grep cerca BPRNACan trova anche BPRNACanPro(met) e BPRNACanProMet quindi nei risultati viene sommato tutto quanto perche si costruisce una tabella con anche le colonne di questi metodi con signature diverse. Provare con un if per escludere proprio i casi sbagliati (in BPRNACan)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
# library(org.Hs.eg.db) # Homo sapiens db
# columns(org.Hs.eg.db) # to look at the columns of this db
# Plots - Heatmap
TPM_Heatmap <- function(TPM){
TPM <- as.matrix(TPM)
# Utilizes the NormalizeTPM function from the ADImpute package.
# Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
# Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
# This is often employed to reduce variance and approximate a normal distribution.
# Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
sampleDists <- dist(t(TPM)) #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,    main = "Sample clustering to detect outliers", sub="", xlab="",
cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Plots - Dendrogram
TPM_Sample_dendrogram <- function(TPM){
sampleTree = hclust(dist(t(TPM)), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Data Loading
path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/all_deconvolutions_BC2_filtered_samples.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
# EDA
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
pdf(paste0("../IMMUCAN_data/", folders_names[[i]][1], "/02_Plot_Outliers/", files_names[i],"_outliers"), width = 16) # folders_names[[i]][1] double square bracket to access to the i vector, single bracket to access to the first value of the i vector
TPM_Heatmap(TPM)
TPM_Sample_dendrogram(TPM)
dev.off()
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
# library(org.Hs.eg.db) # Homo sapiens db
# columns(org.Hs.eg.db) # to look at the columns of this db
# Plots - Heatmap
Compute_Samples_Heatmap <- function(TPM){
TPM <- as.matrix(TPM)
# Utilizes the NormalizeTPM function from the ADImpute package.
# Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
# Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
# This is often employed to reduce variance and approximate a normal distribution.
# Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
sampleDists <- dist(t(TPM)) #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,    main = "Sample clustering to detect outliers", sub="", xlab="",
cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Plots - Dendrogram
Compute_Samples_dendrogram <- function(TPM){
sampleTree = hclust(dist(t(TPM)), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
View(TPM)
TPM <- read.table(path[1], header = TRUE,  sep = '	', row.names = 1)
TPM
View(TPM)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
# library(org.Hs.eg.db) # Homo sapiens db
# columns(org.Hs.eg.db) # to look at the columns of this db
# Plots - Heatmap
Compute_Samples_Heatmap <- function(TPM){
TPM <- as.matrix(TPM)
# Utilizes the NormalizeTPM function from the ADImpute package.
# Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
# Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
# This is often employed to reduce variance and approximate a normal distribution.
# Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
sampleDists <- dist(TPM) #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,    main = "Sample clustering to detect outliers", sub="", xlab="",
cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Plots - Dendrogram
Compute_Samples_dendrogram <- function(TPM){
sampleTree = hclust(dist(t(TPM)), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Data Loading
path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/all_deconvolutions_BC2_filtered_samples.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
# EDA
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
pdf(paste0("../IMMUCAN_data/", folders_names[[i]][1], "/02_Plot_Outliers/", files_names[i],"_outliers"), width = 16) # folders_names[[i]][1] double square bracket to access to the i vector, single bracket to access to the first value of the i vector
Compute_Samples_Heatmap(TPM)
Compute_Samples_dendrogram(TPM)
dev.off()
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
# library(org.Hs.eg.db) # Homo sapiens db
# columns(org.Hs.eg.db) # to look at the columns of this db
# Plots - Heatmap
Compute_Samples_Heatmap <- function(TPM){
TPM <- as.matrix(TPM)
# Utilizes the NormalizeTPM function from the ADImpute package.
# Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
# Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
# This is often employed to reduce variance and approximate a normal distribution.
# Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
sampleDists <- dist(TPM) #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,    main = "Sample clustering to detect outliers", sub="", xlab="",
cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Plots - Dendrogram
Compute_Samples_dendrogram <- function(TPM){
sampleTree = hclust(dist(t(TPM)), method = "average");
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
}
# Data Loading
path <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/all_deconvolutions_BC2_filtered_samples.txt")
files_names <- gsub(".txt$", "", basename(path))
folders_names <- strsplit(files_names, "_")
# EDA
for (i in 1:length(path)) {
TPM <- read.table(path[i], header = TRUE,  sep = '	', row.names = 1)
# pdf(paste0("../IMMUCAN_data/", folders_names[[i]][1], "/02_Plot_Outliers/", files_names[i],"_outliers"), width = 16) # folders_names[[i]][1] double square bracket to access to the i vector, single bracket to access to the first value of the i vector
Compute_Samples_Heatmap(TPM)
Compute_Samples_dendrogram(TPM)
# dev.off()
}
