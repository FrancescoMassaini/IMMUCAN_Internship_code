cell_metadata = pDataDT(SS_seqfish)
field1_ids = cell_metadata[FOV == 0]$cell_ID
subSS_seqfish = subsetGiotto(SS_seqfish, cell_ids = field1_ids)
spatPlot(gobject = subSS_seqfish, show_network = T,
network_color = 'blue', spatial_network_name = 'Delaunay_network',
point_size = 2.5, cell_color = 'cell_types')
## delaunay network: stats + creation
plotStatDelaunayNetwork(gobject = SS_seqfish, maximum_distance = 400, save_plot = F)
# SS_seqfish = createSpatialNetwork(gobject = SS_seqfish, minimum_k = 2, maximum_distance_delaunay = 400)
## create spatial networks based on k and/or distance from centroid
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 5, name = 'spatial_network')
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 10, name = 'large_network')
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 100,
maximum_distance_knn = 200, minimum_k = 2, name = 'distance_network')
## visualize different spatial networks on first field (~ layer 1)
cell_metadata = pDataDT(SS_seqfish)
field1_ids = cell_metadata[FOV == 0]$cell_ID
subSS_seqfish = subsetGiotto(SS_seqfish, cell_ids = field1_ids)
spatPlot(gobject = subSS_seqfish, show_network = T,
network_color = 'blue', spatial_network_name = 'Delaunay_network',
point_size = 2.5, cell_color = 'cell_types')
## delaunay network: stats + creation
plotStatDelaunayNetwork(gobject = SS_seqfish, maximum_distance = 400, save_plot = F)
SS_seqfish = createSpatialNetwork(gobject = SS_seqfish, minimum_k = 2, maximum_distance_delaunay = 400)
## create spatial networks based on k and/or distance from centroid
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 5, name = 'spatial_network')
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 10, name = 'large_network')
SS_seqfish <- createSpatialNetwork(gobject = SS_seqfish, method = 'kNN', k = 100,
maximum_distance_knn = 200, minimum_k = 2, name = 'distance_network')
## visualize different spatial networks on first field (~ layer 1)
cell_metadata = pDataDT(SS_seqfish)
field1_ids = cell_metadata[FOV == 0]$cell_ID
subSS_seqfish = subsetGiotto(SS_seqfish, cell_ids = field1_ids)
spatPlot(gobject = subSS_seqfish, show_network = T,
network_color = 'blue', spatial_network_name = 'Delaunay_network',
point_size = 2.5, cell_color = 'cell_types')
spatPlot(gobject = subSS_seqfish, show_network = T,
network_color = 'blue', spatial_network_name = 'spatial_network',
point_size = 2.5, cell_color = 'cell_types')
## 3 new methods to identify spatial genes
km_spatialfeats = binSpect(SS_seqfish)
#spatGenePlot(SS_seqfish, expression_values = 'scaled', genes = km_spatialfeats[1:4]$feats,
#             point_shape = 'border', point_border_stroke = 0.1,
#             show_network = F, network_color = 'lightgrey', point_size = 2.5,
#             cow_n_col = 2)
## spatial co-expression patterns ##
ext_spatial_genes = km_spatialfeats[1:500]$feats
## 1. calculate gene spatial correlation and single-cell correlation
## create spatial correlation object
spat_cor_netw_DT = detectSpatialCorFeats(SS_seqfish,
method = 'network',
spatial_network_name = 'Delaunay_network',
subset_feats = ext_spatial_genes)
## 2. cluster correlated genes & visualize
spat_cor_netw_DT = clusterSpatialCorFeats(spat_cor_netw_DT,
name = 'spat_netw_clus',
k = 8)
heatmSpatialCorFeats(SS_seqfish, spatCorObject = spat_cor_netw_DT, use_clus_name = 'spat_netw_clus',
heatmap_legend_param = list(title = NULL))
View(cluster_genes_DT)
remotes::install_bitbucket(repo = 'qzhudfci/smfishhmrf-r', ref='master')
hmrf_folder = paste0(my_working_dir,'','11_HMRF')
if(!file.exists(hmrf_folder)) dir.create(hmrf_folder, recursive = T)
my_spatial_genes = km_spatialfeats[1:100]$feats
# do HMRF with different betas
HMRF_spatial_genes = doHMRF(gobject = SS_seqfish,
expression_values = 'scaled',
spatial_genes = my_spatial_genes,
spatial_network_name = 'Delaunay_network',
k = 9,
betas = c(28,2,3),
output_folder = paste0(hmrf_folder, '/', 'Spatial_genes/SG_top100_k9_scaled'))
## view results of HMRF
for(i in seq(28, 32, by = 2)) {
viewHMRFresults2D(gobject = SS_seqfish,
HMRFoutput = HMRF_spatial_genes,
k = 9, betas_to_view = i,
point_size = 2)
}
## add HMRF of interest to giotto object
SS_seqfish = addHMRF(gobject = SS_seqfish,
HMRFoutput = HMRF_spatial_genes,
k = 9, betas_to_add = c(28),
hmrf_name = 'HMRF_2')
## visualize
#spatPlot(gobject = SS_seqfish,
#         cell_color = 'HMRF_2_k9_b.28',        #'HMRF_2_k9_b.28',
#         point_size = 3,
#         coord_fix_ratio = 1)
remotes::install_bitbucket(repo = 'qzhudfci/smfishhmrf-r', ref='master')
View(km_spatialfeats)
hmrf_folder = paste0(my_working_dir,'','11_HMRF')
if(!file.exists(hmrf_folder)) dir.create(hmrf_folder, recursive = T)
my_spatial_genes = km_spatialfeats[1:100]$feats
# do HMRF with different betas
HMRF_spatial_genes = doHMRF(gobject = SS_seqfish,
expression_values = 'scaled',
spatial_genes = my_spatial_genes,
spatial_network_name = 'Delaunay_network',
k = 9,
betas = c(28,2,3),
output_folder = paste0(hmrf_folder, '/', 'Spatial_genes/SG_top100_k9_scaled'))
## view results of HMRF
for(i in seq(28, 32, by = 2)) {
viewHMRFresults2D(gobject = SS_seqfish,
HMRFoutput = HMRF_spatial_genes,
k = 9, betas_to_view = i,
point_size = 2)
}
## add HMRF of interest to giotto object
SS_seqfish = addHMRF(gobject = SS_seqfish,
HMRFoutput = HMRF_spatial_genes,
k = 9, betas_to_add = c(28),
hmrf_name = 'HMRF_2')
## visualize
spatPlot(gobject = SS_seqfish,
cell_color = 'HMRF_2_k9_b.28',
point_size = 3,
coord_fix_ratio = 1)
getwd()
gc()
metasample_df_combined <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_combined <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
View(metagene_df_combined)
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
Heatmap(metasample_df_combined,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
View(metasample_df_combined)
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
library(ComplexHeatmap)
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
library(ComplexHeatmap)
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = TRUE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = TRUE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = TRUE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = TRUE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
class(metasample_df_NSCLC)
metasample_df_NSCLC <- as.matrix(metasample_df_NSCLC)
metagene_df_NSCLC <- as.matrix(metagene_df_NSCLC)
class(metasample_df_NSCLC)
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
Heatmap(metasample_df_NSCLC,
name = "Contribution",
col = heatmap_colors,
clustering_distance_rows = "euclidean",
clustering_distance_columns = "euclidean",
cluster_rows = FALSE,
show_row_names = TRUE,
show_column_names = TRUE,
row_names_gp = gpar(fontsize = 6))
View(metagene_df_combined)
View(metagene_df_NSCLC)
View(metasample_df_combined)
# Chunk 1: Imports
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
# Chunk 2: Functions
source("./Functions.R")
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("../Functions.R")
# Load CellTFusion results
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_Subgroups_NSCLC2.RData")
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_tfs_NSCLC2.RData")
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_modules_deconv_NSCLC2.RData")
deconv_subgroups = dt[["Deconvolution matrix"]]
View(features_sig)
# Load CellTFusion results
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_Subgroups_NSCLC2.RData")
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_tfs_NSCLC2.RData")
load("../../IMMUCAN_data/NSCLC2/04_CellTFusion/CellTFusion_modules_deconv_NSCLC2.RData")
deconv_subgroups = dt[["Deconvolution matrix"]]
TF_moduls_deconv = features_sig[[1]]
View(TF_moduls_deconv)
TF_moduls_deconv = as.data.frame(features_sig[[1]])
TF_modules_deconv = as.data.frame(features_sig[[1]])
View(TF_modules_deconv)
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Correlation
create_correlation_plot(data1 = tfs, data2 = metasample_df, correlation_type = "pearson", r_threshold = 0.7, p_threshold = 0.05)
setwd("/home/francesco.massaini/Desktop/IMMUCAN_Internship_code/BC2/")
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("../Functions.R")
# Load CellTFusion results
load("../../IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_Subgroups_BC2.RData")
load("../../IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_tfs_BC2.RData")
load("../../IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_modules_deconv_BC2.RData")
deconv_subgroups = dt[["Deconvolution matrix"]]
TF_modules_deconv = as.data.frame(features_sig[[1]])
# Load clinical data
TPM = read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_fromAndreaRdata_filtered_Samples.csv", row.names = 1, check.names = FALSE)
clinical_all_columns = read.delim("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/01_Clinical_Data/BC2_clinical_export_20240602.tsv", sep = "\t") %>%
dplyr::filter(immucan_sample_id %in% colnames(TPM)) %>%
dplyr::select(where(~ sum(!is.na(.)) >= 20))
relevant_clinical_columns = c("immucan_patient_id",
"immucan_sample_id",
"surgery_days_after_diag",
"sampling_days_after_diag",
"lymphocyte_infiltration",
"PCR",
# "medical_review_end_point", # full of "pCR (e.g. surgery)". I'm not sure what is the difference with column PCR, perhaps on different time point?
"residual_cancer_burden",
"residual_disease",
# "treatment_setting", # Empty column on the same samples of RNAseq
# "sex", # obviously not so interesting for BC
# "HER2_status", # all negative
# "ER_status", # all negative
# "PR_status", # only 1 patient positive
"KI67_status",
"laterality",
# "disease_evolution", # only three 1 values
"stage",
"N_stage",
# "M_stage", # only cM0 or unknown
"T_stage")
# Filter clinical with only relevant columns and mutate absent ("") values to NA
clinical = clinical_all_columns[, relevant_clinical_columns] %>%
dplyr::select(-all_of(c("surgery_days_after_diag","sampling_days_after_diag", "immucan_patient_id"))) %>% # remove even immucan_patient_id for better further representations
mutate(PCR = if_else(PCR == "", NA, PCR)) %>%
mutate(stage = if_else(stage == "", NA, stage)) %>%
mutate(lymphocyte_infiltration = if_else(lymphocyte_infiltration == "", NA, lymphocyte_infiltration)) %>%
mutate(lymphocyte_infiltration = if_else(lymphocyte_infiltration == "Not Applicable", "Not applicable", lymphocyte_infiltration)) %>%
mutate(residual_cancer_burden = if_else(residual_cancer_burden == "", NA, residual_cancer_burden)) %>%
mutate(residual_disease = if_else(PCR == "", NA, residual_disease)) %>%
column_to_rownames(var = "immucan_sample_id")
identical(rownames(clinical), rownames(deconv_subgroups))
View(clinical)
View(deconv_subgroups)
# Ensure same patients order
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(t(deconv_subgroups),  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(t(deconv_subgroups),  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(is.na(.), "NA", .))) #  quote NAs to show them in th plot
# Compute PCA
pca_result <- FactoMineR::PCA(deconv_subgroups, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on deconv post subgrouping
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "NA", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(deconv_subgroups, n_neighbors = 8, min_dist = 0.1, metric = "euclidean"))
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Correlation
create_correlation_plot(data1 = deconv_subgroups, data2 = metasample_df, correlation_type = "pearson", r_threshold = 0.7, p_threshold = 0.05)
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_BC2_Biodica_meanDuplGenes_ICA/TPM_BC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_BC2_Biodica_meanDuplGenes_ICA/TPM_BC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Correlation
create_correlation_plot(data1 = deconv_subgroups, data2 = metasample_df, correlation_type = "pearson", r_threshold = 0.7, p_threshold = 0.05)
# Ensure same patients order
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(t(tfs),  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(t(tfs),  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(is.na(.), "NA", .))) #  quote NAs to show them in th plot
# Compute PCA
pca_result <- FactoMineR::PCA(tfs, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# PCA biplot on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(is.na(.), "NA", .))) #  quote NAs to show them in th plot
# Compute PCA
pca_result <- FactoMineR::PCA(tfs, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "NA", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(tfs, n_neighbors = 8, min_dist = 0.1, metric = "euclidean"))
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_BC2_Biodica_meanDuplGenes_ICA/TPM_BC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_BC2_Biodica_meanDuplGenes_ICA/TPM_BC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)
# Correlation
create_correlation_plot(data1 = tfs, data2 = metasample_df, correlation_type = "pearson", r_threshold = 0.7, p_threshold = 0.05)
View(metasample_df)
