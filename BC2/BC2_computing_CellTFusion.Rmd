---
title: "Analysis"
author: "Francesco Massaini"
date: "2024-03-26"
output: html_document
---

```{r}
source("src/environment_set.R")
```

Input files
```{r}
# Load TPM and compute deconvolution
TPM = read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_fromAndreaRdata_filtered_Samples.csv", row.names = 1, check.names = FALSE)

deconv_CellTFusion = compute.deconvolution(TPM_matrix = TPM, signatures_exclude = "CD226")
deconv_CellTFusion = as.data.frame(deconv_CellTFusion)

write.table(deconv_CellTFusion ,"../../../Desktop/IMMUCAN_data/BC2/03_Deconvolution/BC2_deconvolution_fromCellTFusion.txt", sep = "\t")

# Load clinical data and clinical samples list 
#clinical_patients_list = readxl::read_excel("../IMMUCAN_data/BC2/01_Reference_files_from_Andrea_BC2_TNBC/BC2_pCR_should_be_ok.xlsx", col_names = FALSE)
#colnames(clinical_patients_list) = c("Patients", "Notes")

# Filtering with Andrea list, we end up with only ~30 patients when intersecated with clinical and less than 25 when intersecated with bulk data. Let's keep patients present in our bulk dataset 
# length(intersect(clinical_patients_list$Patients, str_remove_all(colnames(TPM_filtered_forClustering), pattern = "-FIXT-0[0-9]"))) 

# clinical_all_columns = read.delim("../IMMUCAN_data/BC2/01_Clinical_Data/BC2_clinical_export_20240602.tsv", sep = "\t") %>%
#   dplyr::filter(immucan_patient_id %in% clinical_patients_list$Patients) %>%
#   dplyr::select(where(~ sum(!is.na(.)) >= 20))
# cat("Numb of patients:", length(unique(clinical_all_columns$immucan_patient_id)) , "\nNumb of samples: ", nrow(clinical_all_columns),"\n Not present patients:", setdiff(clinical_patients_list$Patients,unique(clinical_all_columns$immucan_patient_id)))

clinical_all_columns = read.delim("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/01_Clinical_Data/BC2_clinical_export_20240602.tsv", sep = "\t") %>%
  dplyr::filter(immucan_sample_id %in% colnames(TPM)) %>%
  dplyr::select(where(~ sum(!is.na(.)) >= 20))

relevant_clinical_columns = c("immucan_patient_id",
      "immucan_sample_id",
      "surgery_days_after_diag",
      "sampling_days_after_diag",
      "lymphocyte_infiltration",
      "PCR",
      # "medical_review_end_point", # full of "pCR (e.g. surgery)". I'm not sure what is the difference with column PCR, perhaps on different time point?
      "residual_cancer_burden",
      "residual_disease",
      # "treatment_setting", # Empty column on the same samples of RNAseq
      # "sex", # obviously not so interesting for BC
      # "HER2_status", # all negative
      # "ER_status", # all negative
      # "PR_status", # only 1 patient positive
      "KI67_status",
      "laterality",
      # "disease_evolution", # only three 1 values
      "stage",
      "N_stage",
      # "M_stage", # only cM0 or unknown 
      "T_stage")

# Filter clinical with only relevant columns and mutate absent ("") values to NA
clinical = clinical_all_columns[, relevant_clinical_columns] %>%
  dplyr::select(-all_of(c("surgery_days_after_diag","sampling_days_after_diag", "immucan_patient_id"))) %>% # remove even immucan_patient_id for better further representations
  mutate(PCR = if_else(PCR == "", NA, PCR)) %>%
  mutate(stage = if_else(stage == "", NA, stage)) %>%
  mutate(lymphocyte_infiltration = if_else(lymphocyte_infiltration == "", NA, lymphocyte_infiltration)) %>%
  mutate(lymphocyte_infiltration = if_else(lymphocyte_infiltration == "Not Applicable", "Not applicable", lymphocyte_infiltration)) %>%
  mutate(residual_cancer_burden = if_else(residual_cancer_burden == "", NA, residual_cancer_burden)) %>%
  mutate(residual_disease = if_else(PCR == "", NA, residual_disease)) %>%
  column_to_rownames(var = "immucan_sample_id")

# Load previously computed deconvolution
deconv = read.delim("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/03_Deconvolution/BC2_deconvolution_fromCellTFusion.txt", sep = "\t", check.names = FALSE)
traitData = clinical
counts.norm = read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/BC2/02_TPM/BC2_fromAndreaRdata_filtered_Samples.csv", row.names = 1, check.names = FALSE) 

identical(colnames(counts.norm), rownames(traitData))
```

CellTFusion

1. TFs inference
```{r}
tfs = compute.TFs.activity(counts.norm)
save(tfs, file = "../../../Desktop/IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_tfs_BC2.RData")
```

2. TFs network construction
Group meeting 31/10/2023 slide 27. All the pass
corr_mod value from 0 to 1 used for merge modules in a second
iteration. After the first TF-module construction, a correlation
will take place between modules and modules correlated by a
threshold higher than this value will be merged. Default value
is 0.8. Simile a quello che si fa con le features alla fine 
```{r}
network = compute.WTCNA(tfs, corr_mod = 0.8, clustering.method = "ward.D2") # Soft_Threshold file is in usr_projects/Results

# Association of TFs modules with clinical data
compute.metada.association(network[[1]], traitData, pval = 0.05, width = 10) 
```

3. Modules characterization
Questioni relative all'enrichment. I moduli sono costituiti da TFs ma se fai l'arricchimento di questi geni rispetto ad un universo che e' tutti i geni, ottieni come risultato l-arricchimento in "Regolazione genica". 
Per evitare cio' e ottenere l'arricchimento in cosa fanno effettivamente i moduli, quello che fai e' prendere i geni regolati da questi TF (e la funzione compute.modules.enrichment prima estrae questi geni dal totale dei dati) e fare l-arricchimento di questi target genes contro l'universo di tutti i geni. 
In alternativa potresti ridurre l'universo a tutti i TF possibili e vedere se questi sono arricchiti. Se pero' riduci l'universo ci sono dei problemi statistici.

To avoid common enrichment results
because of the overlapping of several target genes, a step to filter and only keep unique pathways by
module is done.

```{r}
# Probably tfs used to extract tf and found all the genes. network[[1]] e' la matrice con tutti i moduli per i vari samples e network[[2]] e' una lista di caratteri che corrispondono a quale TF corrisponde a quele modulo
library(enrichplot) 
compute.modules.enrichment(counts.norm, tfs, network[[1]], network[[2]])
```

4. Pathways activity inference
```{r}
# Additional characterization of TFs modules is done by performing a Gene Set Variation Analysis (GSVA) using Progeny and Hallmarks signatures from MsigDB.

pathways = compute.pathway.activity(counts.norm)
#Association of TFs modules with pathways
compute.modules.relationship(network[[1]], pathways, "Pathways_Progeny-TFs_Modules", width = 15)
```

5. Deconvolution analysis
The function computes linear and proportional correlations to produce cell subgroups of methods and
signatures correlated for above a specific threshold within each cell type.
```{r}
deconvolution = fix.names.GEMDeCan(deconv)
dt = compute.deconvolution.analysis(deconvolution, corr = 0.7, high_corr = 0.99)
save(dt, file = "../../../Desktop/IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_Subgroups_BC2.RData")
#Association of TFs modules with deconvolution 
compute.modules.relationship(network[[1]], dt[[1]], "Deconvolution-TFs_Modules", vertical = T, height = 30, width = 10, pval = 0.1)
```

6. Identify cell groups from significant deconvolution features across TFs modules

(7 sul html)

Once deconvolution subgroups are calculated, a following pearson correlation is done across the different TFs modules to spot which features are significant associated (default pval < 0.05) with these TFs groups.

features_sig = compute.modules.relationship(network[[1]], dt[[1]], "Deconvolution-TFs_Modules", width = 30, return = T)


8. Identify cell groups

Hierarchical clustering of the different cell groups is computed first across each TFs module independently and after across all at once. Different dendrograms are saved in your directory.


```{r}
features_sig = compute.modules.relationship(network[[1]], dt[[1]], return = T) # 7 html Ripetuto mi sa
save(features_sig, file = "../../../Desktop/IMMUCAN_data/BC2/04_CellTFusion/CellTFusion_modules_deconv_BC2.RData")
cell_dendrograms = identify.cell.groups(dt[[1]], network[[1]], features_sig, height = 20) # 8 html 
```