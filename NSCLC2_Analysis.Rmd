---
title: "NSCLC2"
author: "Francesco Massaini"
date: "2024-03-28"
output: html_document
---

# Imports
```{r Imports}
library(dplyr)
library(tibble)
library(tidyr)
library(org.Hs.eg.db) # Homo sapiens db
library(stringr)
library(RColorBrewer) # for plot
library(pheatmap) # for heatmaps
library(ADImpute) # This package provides functions to compute TPM
library(ggplot2)
library(FactoMineR)
library(factoextra)
library(survival)
library(ranger)
library(ggfortify)
library(rlang)
library(purrr)
```

# Functions
```{r Functions}
# Remove version number from ENSEMBL ID
remove_gene_version <- function(df_with_gene_version) {
  rownames(df_with_gene_version) <- rownames(df_with_gene_version) %>% 
    str_remove("\\..*$") 
  return(as.data.frame(df_with_gene_version))
}

# Converting from ENSEMBL ID to GENE SYMBOL. Use org.Hs.eg.db db 
EnsemblID_to_GeneSymbol <- function(raw_counts_file){
  entrz <- AnnotationDbi::select(org.Hs.eg.db, keys = rownames(raw_counts_file), columns = "SYMBOL", keytype = "ENSEMBL") # keys are the data to overlap. columns is the column to replace and keytype is the column where to find corrispondences   # entrz is a df storing ENSEMBL ID and GENE SYMBOLS. ENSEMBL ID are selected by the ROW NAMES of your raw_counts_file 
  raw_counts_file <- raw_counts_file %>%
    mutate(ENSEMBL = rownames(raw_counts_file)) %>% # add a column
    inner_join(., entrz, by="ENSEMBL") %>% # join, merge df with a common column (ENSEMBL)
    dplyr::filter(!is.na(SYMBOL)) %>%
    distinct(SYMBOL, .keep_all = T) %>% # keep only one variable of the duplicated symbols
    column_to_rownames("SYMBOL") %>% 
    dplyr::select(., -c("ENSEMBL"))
return(raw_counts_file)  
}

# Raw counts to TPM. Need GENE SYMBOL!
counts_to_TPM <- function(raw_counts_file){
  # log2(TPM+1) 
  TPM <- ADImpute::NormalizeTPM(raw_counts_file, log = T)
return(as.data.frame(TPM))  
}


# Plots - Heatmap
Compute_Samples_Heatmap <- function(df){
  df <- as.matrix(df)
  
  # Utilizes the NormalizeTPM function from the ADImpute package.
  # Performs normalization on the 'TPM' data frame, considering TPM (Transcripts Per Million) values.
  # Setting 'log = T' indicates that the normalization will be done using the logarithm of TPM values.
  # This is often employed to reduce variance and approximate a normal distribution.
  # Add 1 at the log log(TPM+1) so that 0 values are propertly calculated
  
  sampleDists <- dist(t(df), method = 'euclidean') #Compute distance of the matrix. DO NOT DO IT FOR GENES. dist take into account rows! So to look at the patients you need to transpose. Distance is computed with eucledian metric. Remember you need to transpose (t) the matrix because dist takes rows (and samples are into columns) 
  sampleDistMatrix <- as.matrix(sampleDists)
  colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
  pheatmap(sampleDistMatrix,    main = "Samples heatmap", sub="", xlab="",
       cex.lab = 1, cex.axis = 1, cex.main = 2, clustering_method = 'complete')
}

# Plots - Dendrogram
Compute_Samples_dendrogram <- function(df){
  sampleTree = hclust(dist(t(df), method = 'euclidean'), method = "complete");
  plot(sampleTree, main = "Samples dendrogram", sub="", xlab="", 
       cex.lab = 1, cex.axis = 1, cex.main = 2)
}


# Correlation
cors <- function(df) {
  M <- Hmisc::rcorr(as.matrix(df))
  Mdf <- map(M, ~data.frame(.x))
  return(Mdf)
}

formatted_cors <- function(df){
  cors(df) %>%
    map(~rownames_to_column(.x, var="measure1")) %>%
    map(~pivot_longer(.x, -measure1, names_to = "measure2", values_to = "value")) %>%
    bind_rows(.id = "id") %>%
    pivot_wider(names_from = id, values_from = value) %>%
    mutate(sig_p = ifelse(P < .05, T, F),
           p_if_sig = ifelse(sig_p, P, NA),
           r_if_sig = ifelse(sig_p, r, NA)) 
}

```

# Path and folders
```{r Data loading}
# Imposta il percorso della cartella
input_folder <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/02_TPM/"

# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)

# Stampa il contenuto della variabile txt_files
# print(txt_input_files)

files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)

```

# load and processign data NSCLC2
```{r Processing Raw Counts}

# Merging all the patients files, filtering rows of input files, removing gene version, and converting to GENE SYMBOLS

merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]

for (i in 2:length(txt_input_files)) {
  # print(i)
    # Leggi il data frame successivo
  counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
  colnames(counts) <- samples_names[i]
  # print(samples_names[i])
  # Unisci le colonne del nuovo data frame a merged_counts
  merged_counts <- cbind(merged_counts, counts)
}
  merged_counts <- merged_counts %>%
    filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
    remove_gene_version() %>%
    EnsemblID_to_GeneSymbol()

# ADImpute to normalize to TPM
TPM <- counts_to_TPM(merged_counts)
```

# Analizing TPM
```{r Distribution}
# Summary
summary(TPM)

TPM_long <- pivot_longer(TPM, cols = 2:ncol(TPM), names_to = "Samples", values_to = "TPM")
# Histogram
ggplot(data = TPM_long, aes(x=TPM)) + 
  geom_histogram(binwidth = 0.05) +
  geom_rug(color = "blue") +
  scale_x_continuous(limits = c(0, max(TPM_long$TPM))) +
  scale_y_continuous(limits = c(0, 100000))
# scale_y_continuous(limits = c(-100, 800000))

# Jitter plot  
ggplot(data = TPM_long, aes(x = TPM, y = 0)) +
  geom_jitter(width = 0, height = 0.1, size = 1, alpha = 0.5) +
  xlab("TPM") +
  ylab("")
```

# TPM Analysis
```{r Heatmap and dendrogram}
# Heatmap and dendrogram to see patient outliers on TPM

output_folder_TPM_outlier <- paste0(str_split_i(output_folder, "02_TPM/", 1), "02_Plot_Outliers/")

# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
png(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.png"), width = 2000, height = 2000)
Compute_Samples_Heatmap(TPM)
dev.off()
# dev.off()

# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"))
png(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.png"), width = 2000, height = 1000)
Compute_Samples_dendrogram(TPM)
dev.off()
# dev.off()


# PCA biplot on TPM

pca_result <- PCA(t(TPM), scale.unit = TRUE, graph = FALSE) # t(BC2) because PCA takes rows 
fviz_eig(pca_result)

# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
png(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.png"))
factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var") # repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
dev.off()
# dev.off()
```

# Loading Deconvolution Data
```{r Loading Deconvolution}
# Deconvoltion Data Loading
input_folder_deconvolution <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/"
output_folder_deconvolution <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/"
txt_input_files_deconvolution <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/all_deconvolutions_NSCLC2_TPM_noCD226_signatureCLLpatient3.txt")
files_names_deconvolution <- gsub(".txt$", "", basename(txt_input_files_deconvolution))

deconv <- read.table(txt_input_files_deconvolution, header = TRUE,  sep = '	', row.names = 1)

```

# Preliminary Deconvolution Analisys ON DECONVOLUTION DATA
```{r Deconvolution}
# Sample clustering
# pdf(paste0(output_folder_deconvolution, files_names_deconvolution, "_deconvolution_samples_heatmap.pdf"), width = 2000, height = 2000)
png(paste0(output_folder_deconvolution, files_names_deconvolution, "_deconvolution_samples_heatmap.png"), width = 2000, height = 2000)
Compute_Samples_Heatmap(t(deconv)) # double t() (here and in the function) to take into account rows
dev.off()
# dev.off()

# pdf(paste0(output_folder_deconvolution, files_names_deconvolution, "_deconvolution_samples_clustering.pdf"), width = 2000, height = 2000)
png(paste0(output_folder_deconvolution, files_names_deconvolution, "_deconvolution_samples_clustering.png"), width = 2000, height = 1000)
Compute_Samples_dendrogram(t(deconv))
dev.off()
# dev.off()

# PCA
pca_result <- PCA(deconv, scale.unit = TRUE, graph = FALSE) # t(deconv) because PCA takes rows 
fviz_eig(pca_result)

# pdf(paste0(output_folder_deconvolution, "deconvolution_samples_PCA.pdf"))
png(paste0(output_folder_deconvolution, "deconvolution_samples_PCA.png"))
factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var") # repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
dev.off()
# dev.off()

```

# Benchmark of deconvolution results vs mIF data
```{r Correlation Deconv vs mIF}
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data  
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>% 
  str_remove_all("-IF1-01")

IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>% 
  str_remove_all("-IF2-01")

IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>% 
  str_remove_all("-IF3-01")
  
rownames(deconv) <- rownames(deconv) %>%
  str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")


# Keeping only common patients and subsetting deconv and IF 
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]

# # Dividing all_markers from cell_types  
# IF_cell_types <- IF_common[,1:9]
# IF_markers <- IF_common[,10:15]

# Merging all the mIF files

merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data

# all vs all Correlation and image

correlation_matrix = cors(merged_df)


corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
# Nella sintassi result[[1]][result[[3]] >= 0.05] <- NA, stiamo applicando una logica vettorizzata. Ecco cosa succede passo per passo:
# 
# Accesso ai Dataframe: result[[1]] e result[[3]] accedono rispettivamente al primo e al terzo elemento della lista result. In R, le liste sono strutture dati che possono contenere oggetti di vario tipo, inclusi i dataframe. L'operatore [[ ]] viene usato per accedere agli elementi di una lista.
# 
# Condizione Vettorizzata: result[[3]] >= 0.05 crea un vettore logico della stessa dimensione di result[[3]], dove ogni elemento è TRUE se il corrispondente valore di 
# �
# p è maggiore o uguale a 0.05, e FALSE altrimenti.
# 
# Indicizzazione Logica: Quando usi un vettore logico per indicizzare un dataframe o una matrice, selezioni solo gli elementi per i quali il vettore logico ha valore TRUE. Quindi, result[[1]][result[[3]] >= 0.05] seleziona tutti gli elementi in result[[1]] (i valori di 
# �
# r) che corrispondono ai valori di 
# �
# p in result[[3]] che sono 
# ≥
# 0.05
# ≥0.05.
# 
# Assegnazione: Il <- NA assegna NA a tutti gli elementi selezionati nel passaggio precedente.
# 

corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)

# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA

feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])

mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric 

corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value 

high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"), 
                              "Feature1" = rownames(corr_mat_adjusted)[feature1_index], 
                              "ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"), 
                              "Feature2" = colnames(corr_mat_adjusted)[feature2_index],
                              "Corr" = corr_values)

high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]

# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF")) %>%
  arrange(Corr)

ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
  geom_tile() +
  labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations Deconvolution Features vs mIF",
       subtitle="Only significant Pearson's correlation coefficients shown") +
  scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
  geom_text() +
  theme_classic() +
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0)) +
  theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  xlab("mIF") + 
  ylab("Deconvolution Features")

ggsave(filename = paste0(output_folder_deconvolution, "deconvolution_vs_IF1.png"), plot = last_plot(), width = 20, height = 20)



ggplot(a, aes(x=B_fraction, y=XCell_B_cell)) +
  geom_point() +
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)

```

# Deconvolution results of BPRNACan3DProMet_M2 vs ALL clinical data 
```{r BPRNACan3DProMet_M2}
# loading clinical file and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data  
clinical <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv", header = 1) %>%
  column_to_rownames(var = "immucan_id")
  
rownames(deconv) <- rownames(deconv) %>%
  str_remove_all(pattern = "-FIXT-01-RNA-01|-FIXT-01-RNA-02")

# Keeping only common patients and subsetting deconv and IF 
common_patients <- intersect(rownames(clinical), rownames(deconv))
clinical_common <- clinical[common_patients,] %>%
  dplyr::select(death, gender, stage, side_localization, smoking_status, neo_adjuvant_treatment, adjuvant_treatment, type_of_adj_trt, metastatic_treatment, simple_histology, simple_stage, primary_localization, long_survivors, T_stage, M_stage, N_stage, primary_tumor_size, TIL_score)
deconv_common <- deconv[common_patients, ] %>%
  dplyr::select(grep("*._BPRNACan3DProMet_M2|CBSX_LM22_Macrophages_M2", colnames(deconv)))


merged_df_clinical <- cbind(clinical_common, deconv_common)
merged_df_clinical[1:18] <- lapply(merged_df_clinical[1:18], factor)

for (i in colnames(merged_df_clinical)[19:ncol(merged_df_clinical)]) {
  for (j in colnames(merged_df_clinical)[1:18]) {
    if (is.factor(merged_df_clinical[[j]]) && is.numeric(merged_df_clinical[[i]])) {
      data_no_na <- na.omit(merged_df_clinical[, c(i, j)])
      
      if (length(unique(data_no_na[[j]])) > 2) {
        # ANOVA
        formula <- as.formula(paste(i, "~", j))
        test_result <- aov(formula, data = data_no_na)
        summary_result <- summary(test_result)
        p_value <- round(summary_result[[1]]$'Pr(>F)'[1], digit = 3)
      } else {
        # Test t
        formula <- as.formula(paste(i, "~", j))
        test_result <- t.test(formula, data = data_no_na)
        p_value <- round(test_result$p.value, digit = 3)
      }
      
      # Grafico
      plot <- ggplot(data_no_na, aes_string(x = j, y = i, fill = j)) +
        geom_violin() +
        labs(title = paste("Violin plot of", i, "by", j), subtitle = paste("p-value:", p_value)) +
        theme(axis.text.x = element_text(angle = 90))
      
      
      
       if(p_value<0.08) print(plot)
    }
  }
}


clinical_common2 <- clinical[common_patients,] %>%
  dplyr::select(death, time_to_event, age_at_registration, age_at_diagnosis, average_number_of_cigarettes, number_of_years, tumor_area_mm_square)
merged_df_clinical2 <- cbind(clinical_common2, deconv_common)

merged_df_clinical2 = mutate(merged_df_clinical2, death = ifelse(death == "Yes", 1, 0))
merged_df_clinical2 = mutate(merged_df_clinical2, M2_Epidish = ifelse(Epidish_BPRNACan3DProMet_M2 > median(Epidish_BPRNACan3DProMet_M2, na.rm = TRUE), "H", "L"))
merged_df_clinical2 = mutate(merged_df_clinical2, M2_DeconRNASeq = ifelse(DeconRNASeq_BPRNACan3DProMet_M2 > median(DeconRNASeq_BPRNACan3DProMet_M2, na.rm = TRUE), "H", "L"))
merged_df_clinical2 = mutate(merged_df_clinical2, M2_CBSX_BPRNACan = ifelse(CBSX_BPRNACan3DProMet_M2 > median(CBSX_BPRNACan3DProMet_M2, na.rm = TRUE), "H", "L"))
merged_df_clinical2 = mutate(merged_df_clinical2, M2_CBSX_LM22 = ifelse(CBSX_LM22_Macrophages_M2 > median(CBSX_LM22_Macrophages_M2, na.rm = TRUE), "H", "L"))

km_trt_fit <- survfit(Surv(time_to_event, death) ~ M2_Epidish, data=merged_df_clinical2)
# Test delle differenze tra le curve di sopravvivenza
surv_diff_result <- survdiff(Surv(time_to_event, death) ~ M2_Epidish, data = merged_df_clinical2)

# Estrazione del p-value
p_value <- 1 - pchisq(surv_diff_result$chisq, length(surv_diff_result$n) - 1)

if(p_value < 0.05) autoplot(km_trt_fit)
print(p_value)



km_trt_fit <- survfit(Surv(time_to_event, death) ~ M2_DeconRNASeq, data=merged_df_clinical2)
# Test delle differenze tra le curve di sopravvivenza
surv_diff_result <- survdiff(Surv(time_to_event, death) ~ M2_Epidish, data = merged_df_clinical2)

# Estrazione del p-value
p_value <- 1 - pchisq(surv_diff_result$chisq, length(surv_diff_result$n) - 1)

if(p_value < 0.05) autoplot(km_trt_fit)
print(p_value)




km_trt_fit <- survfit(Surv(time_to_event, death) ~ M2_CBSX_BPRNACan, data=merged_df_clinical2)
# Test delle differenze tra le curve di sopravvivenza
surv_diff_result <- survdiff(Surv(time_to_event, death) ~ M2_Epidish, data = merged_df_clinical2)

# Estrazione del p-value
p_value <- 1 - pchisq(surv_diff_result$chisq, length(surv_diff_result$n) - 1)

if(p_value < 0.05) autoplot(km_trt_fit)
print(p_value)



km_trt_fit <- survfit(Surv(time_to_event, death) ~ M2_CBSX_LM22, data=merged_df_clinical2)
# Test delle differenze tra le curve di sopravvivenza
surv_diff_result <- survdiff(Surv(time_to_event, death) ~ M2_Epidish, data = merged_df_clinical2)

# Estrazione del p-value
p_value <- 1 - pchisq(surv_diff_result$chisq, length(surv_diff_result$n) - 1)

# if(p_value < 0.05) 
autoplot(km_trt_fit)
print(p_value)


ggplot(merged_df_clinical2, aes(x=time_to_event, y=Epidish_BPRNACan3DProMet_M2)) +
  geom_point() +
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)

# long_df <- pivot_longer(merged_df_clinical, 
#                         cols = -death,                         
#                         names_to = "variable", 
#                         values_to = "value")

# ggplot(long_df, aes(x = variable, y = value, fill=death)) +
#   geom_violin() +
#   scale_y_continuous(limits = c(-0.0001, 0.0020)) + # Sostituisci ymin e ymax con i valori desiderati
#   theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```

# Loading CellTFusion data
```{r CellTFusion Loading}
CellTFusion <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/Deconvolution_after_subgrouping.csv", header = 1, row.names = 1)

```


# Benchmark of CellTFusion deconvolution results vs mIF data
```{r Correlation CellTFusion vs mIF}
output_folder_CellTFusion <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/" 

# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data  
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>% 
  str_remove_all("-IF1-01")

IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>% 
  str_remove_all("-IF2-01")

IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>% 
  str_remove_all("-IF3-01")
  
rownames(CellTFusion) <- rownames(CellTFusion) %>%
  str_remove_all(pattern = "-RNA-01|-RNA-02|-RNA-04")


# Keeping only common patients and subsetting deconv and IF 
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(CellTFusion)))
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
CellTFusion_common <- CellTFusion[common_patients,]

# # Dividing all_markers from cell_types  
# IF_cell_types <- IF_common[,1:9]
# IF_markers <- IF_common[,10:15]

# Merging all the mIF files

merged_df <- cbind(IF1_common, IF2_common, IF3_common, CellTFusion_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data


# all vs all Correlation and image

correlation_matrix = cors(merged_df)


corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
# Nella sintassi result[[1]][result[[3]] >= 0.05] <- NA, stiamo applicando una logica vettorizzata. Ecco cosa succede passo per passo:
# 
# Accesso ai Dataframe: result[[1]] e result[[3]] accedono rispettivamente al primo e al terzo elemento della lista result. In R, le liste sono strutture dati che possono contenere oggetti di vario tipo, inclusi i dataframe. L'operatore [[ ]] viene usato per accedere agli elementi di una lista.
# 
# Condizione Vettorizzata: result[[3]] >= 0.05 crea un vettore logico della stessa dimensione di result[[3]], dove ogni elemento è TRUE se il corrispondente valore di 
# �
# p è maggiore o uguale a 0.05, e FALSE altrimenti.
# 
# Indicizzazione Logica: Quando usi un vettore logico per indicizzare un dataframe o una matrice, selezioni solo gli elementi per i quali il vettore logico ha valore TRUE. Quindi, result[[1]][result[[3]] >= 0.05] seleziona tutti gli elementi in result[[1]] (i valori di 
# �
# r) che corrispondono ai valori di 
# �
# p in result[[3]] che sono 
# ≥
# 0.05
# ≥0.05.
# 
# Assegnazione: Il <- NA assegna NA a tutti gli elementi selezionati nel passaggio precedente.
# 

corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)

# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA

feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])

mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric 

corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value 

high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "CellTFusion"), 
                              "Feature1" = rownames(corr_mat_adjusted)[feature1_index], 
                              "ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "CellTFusion"), 
                              "Feature2" = colnames(corr_mat_adjusted)[feature2_index],
                              "Corr" = corr_values)

high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]

# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_CellTFusion <- filter(high_corr_pairs_filtered, ID1 == "CellTFusion", ID2 == "CellTFusion")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
  arrange(Corr)

ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
  geom_tile() +
  labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
       subtitle="Only significant Pearson's correlation coefficients shown") +
  scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
  geom_text() +
  theme_classic() +
  scale_x_discrete(expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0)) +
  theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  xlab("mIF") + 
  ylab("CellTFusion Features") 

ggsave(filename = paste0(output_folder_CellTFusion, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)



# ggplot(a, aes(x=B_fraction, y=XCell_B_cell)) +
#   geom_point() +
#   geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE)


```




# TO DO
```{r}
 
# Analisi Risultati di deconvoluzione in termini di stackable histograms
# heatmap sui samples e PCA sulla deconvoluzione

# CellTFusion
```


# Saving file
```{r Saving file}
# Write file in the correct format for deconvolution
TPM <- rownames_to_column(TPM, "Genes") 
name <- "NSCLC2" 

write.table(TPM, file = paste0(output_folder, name,"_TPM.txt"), quote = F, sep = "\t", row.names = F)
message(paste0(output_folder, name,"_TPM.txt"))
```