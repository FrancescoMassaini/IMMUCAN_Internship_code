# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() + theme(plot.title = element_text(size=3))
plots = append(plots, list(p))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
plot_layout(guides = 'collect') + # arrange tha layout
plot_annotation(title = "PCoA Plots with Different Metadata") # specify a title for all patchwork
print(combined_plot)
}
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
compute_pcoa <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7)
)
plots = append(plots, list(p))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
plot_layout(guides = 'collect') + # arrange tha layout
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
}
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
compute_pcoa <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7)
)
plots = append(plots, list(p))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
}
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
compute_pcoa <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots = append(plots, list(p))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
}
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
plots = compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = "euclidean")
distance_methods <- c("euclidean", "bray", "manhattan", "jaccard", "pearson","spearman")
# PCoA
for (dist_method in distance_methods) {
compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
# PCoA
for (dist_method in distance_methods) {
compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
distance_matrix <- vegdist(as.matrix(TPM_filtered_forClustering), method = "euclidean")
distance_matrix <- vegdist(t(TPM_filtered_forClustering), method = "euclidean")
# Esegui NMDS
nmds_result <- metaMDS(distance_matrix, trymax = 100)
View(nmds_result)
distance_matrix <- vegdist(t(TPM_formatted_for_clinical), method = "euclidean")
# Esegui NMDS
nmds_result <- metaMDS(distance_matrix, trymax = 100)
# Estrai i punteggi NMDS
nmds_scores <- as.data.frame(scores(nmds_result))
View(nmds_scores)
ggplot(data = nmds_scores, aes(x=NMDS1, y = NMDS2)) +
geom_point(size=2)
compute_pcoa <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
ggplot(data = nmds_scores, aes(x=NMDS1, y = NMDS2)) +
geom_point(size=2)
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Perform NMDS
nmds_result <- metaMDS(distance_matrix, trymax = 100)
nmds_scores <- as.data.frame(scores(nmds_result))
nmds_scores = rownames_to_column(nmds_scores, var = "Sample")
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA and NMDS data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
plots_nmds = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
df2 = left_join(nmds_scores, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df2)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots = append(plots, list(p))
p_nmds = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "NMDS1", y = "NMDS2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots_nmds = append(plots, list(p_nmds))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
}
# PCoA
for (dist_method in distance_methods) {
compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
compute_pcoa <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
ggplot(data = nmds_scores, aes(x=NMDS1, y = NMDS2)) +
geom_point(size=2)
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Perform NMDS
nmds_result <- metaMDS(distance_matrix, trymax = 100)
nmds_scores <- as.data.frame(scores(nmds_result))
nmds_scores = rownames_to_column(nmds_scores, var = "Sample")
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA and NMDS data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
plots_nmds = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
df2 = left_join(nmds_scores, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df2)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots = append(plots, list(p))
p_nmds = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "NMDS1", y = "NMDS2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots_nmds = append(plots, list(p_nmds))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
combined_plot_nmds <- wrap_plots(plots_nmds) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "NMDS Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot_nmds)
}
# PCoA
for (dist_method in distance_methods) {
compute_pcoa(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
# Plots - PCA
## Automatically compute on samples: SAMPLES MUST BE ON EXPR DF COLUMNS, as it is common to have
Compute_PCA_biplot = function(expr_df, sample_metadata_df = NULL){
pca_result <- FactoMineR::PCA(t(expr_df), scale.unit = TRUE, graph = FALSE)
PCs_var = fviz_eig(pca_result) # Scree plot: explained variance by PCs
print(PCs_var)
plot_list <- list()
# basic PCA
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
palette = "Dark2",
ggtheme = theme_minimal())
plot_list[["Basic PCA Biplot"]] <- p
# PCA with clinical feature ellipses
if(is.null(sample_metadata_df) == FALSE) {
for (feat in colnames(sample_metadata_df)){
p_with_feat = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(sample_metadata_df[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
plot_list[[feat]] <- p_with_feat
}
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
combined_plot <- wrap_plots(plot_list) +
#plot_layout(guides = 'collect') +
plot_annotation(
title = "PCA Biplots",
theme = theme(
plot.title = element_text(size = 8)
)
) +
theme(plot.margin = margin(1, 1, 1, 1, "cm"))
print(combined_plot)
}
# PCA biplot on TPM
clinical <- clinical %>%
mutate_all(~ifelse(is.na(.), "NA", .)) # Replace NA with "NA" to show NA values on fviz_pca_biplot
# check if patients are in the same order
identical(rownames(clinical), colnames(TPM_formatted_for_clinical))
Compute_PCA_biplot(TPM_formatted_for_clinical, clinical)
distance_methods <- c("euclidean", "bray", "manhattan", "jaccard", "pearson","spearman")
# PCoA and NMDS (NMDS is computed on ranks of the distance matrix)
for (dist_method in distance_methods) {
compute_pcoa_nmds(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
compute_pcoa_nmds <- function(expr_df, sample_metadata_df, distance_method = "euclidean") {
# Calculate distance based on the chosen method
if (distance_method == "spearman" || distance_method == "pearson") {
cor_matrix <- cor(expr_df, method = distance_method)
distance_matrix <- as.dist(1 - cor_matrix)
} else {
distance_matrix <- vegdist(t(expr_df), method = distance_method)
}
ggplot(data = nmds_scores, aes(x=NMDS1, y = NMDS2)) +
geom_point(size=2)
# Perform PCoA
pcoa_result <- cmdscale(distance_matrix, eig = TRUE, k = 2)
# Perform NMDS
nmds_result <- metaMDS(distance_matrix, trymax = 100)
nmds_scores <- as.data.frame(scores(nmds_result))
nmds_scores = rownames_to_column(nmds_scores, var = "Sample")
# Create a data frame with PCoA results
pcoa_df <- data.frame(Sample = rownames(pcoa_result[["points"]]),
PC1 = pcoa_result[["points"]][, 1],
PC2 = pcoa_result[["points"]][, 2])
# Join the PCoA and NMDS data frame with the metadata
sample_metadata_df = rownames_to_column(sample_metadata_df, var = "Sample")
plots = list()
plots_nmds = list()
# Loop through each column in sample_metadata_df
for (col_name in colnames(sample_metadata_df)) {
if (col_name != "Sample") {
# Create and display the plot
df <- left_join(pcoa_df, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df)[4] = "groups"
df2 = left_join(nmds_scores, sample_metadata_df[,c(col_name, "Sample"), drop = FALSE], by = "Sample")
colnames(df2)[4] = "groups"
p = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "PCoA1", y = "PCoA2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots = append(plots, list(p))
p_nmds = ggplot(df, aes(x = PC1, y = PC2, color = groups)) +
geom_point(size = 2) +
labs(title = paste("PCoA with", distance_method, "Distance"),
x = "NMDS1", y = "NMDS2", color = col_name) +
theme_minimal() +
theme(
plot.title = element_text(size = 7),
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
legend.box.margin = margin(-10, 0, -10, 0)
)
plots_nmds = append(plots, list(p_nmds))
}
}
combined_plot <- wrap_plots(plots) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "PCoA Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot)
combined_plot_nmds <- wrap_plots(plots_nmds) + # wrap unify all the plots in a list
# plot_layout(guides = 'collect') + # arrange all legends in an unique legend
plot_annotation(title = "NMDS Plots with Different Metadata",
theme = theme(plot.title = element_text(size = 8))) # specify a title for all patchwork
print(combined_plot_nmds)
}
# PCA biplot on TPM
clinical <- clinical %>%
mutate_all(~ifelse(is.na(.), "NA", .)) # Replace NA with "NA" to show NA values on fviz_pca_biplot
# check if patients are in the same order
identical(rownames(clinical), colnames(TPM_formatted_for_clinical))
Compute_PCA_biplot(TPM_formatted_for_clinical, clinical)
distance_methods <- c("euclidean", "bray", "manhattan", "jaccard", "pearson","spearman")
# PCoA and NMDS (NMDS is computed on ranks of the distance matrix)
for (dist_method in distance_methods) {
compute_pcoa_nmds(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
# Plots - PCA
## Automatically compute on samples: SAMPLES MUST BE ON EXPR DF COLUMNS, as it is common to have
Compute_PCA_biplot = function(expr_df, sample_metadata_df = NULL){
pca_result <- FactoMineR::PCA(t(expr_df), scale.unit = FALSE, graph = FALSE)
PCs_var = fviz_eig(pca_result) # Scree plot: explained variance by PCs
print(PCs_var)
plot_list <- list()
# basic PCA
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
palette = "Dark2",
ggtheme = theme_minimal())
plot_list[["Basic PCA Biplot"]] <- p
# PCA with clinical feature ellipses
if(is.null(sample_metadata_df) == FALSE) {
for (feat in colnames(sample_metadata_df)){
p_with_feat = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(sample_metadata_df[,feat]),
addEllipses = T, ellipse.level=0.95, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
plot_list[[feat]] <- p_with_feat
}
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
combined_plot <- wrap_plots(plot_list, ncol = 2, heights = c(1, 1, rep(2, length(plot_list) - 2))) +
#plot_layout(guides = 'collect') +
plot_annotation(
title = "PCA Biplots",
theme = theme(
plot.title = element_text(size = 8)
)
)
print(combined_plot)
}
# PCA biplot on TPM
clinical <- clinical %>%
mutate_all(~ifelse(is.na(.), "NA", .)) # Replace NA with "NA" to show NA values on fviz_pca_biplot
# check if patients are in the same order
identical(rownames(clinical), colnames(TPM_formatted_for_clinical))
Compute_PCA_biplot(TPM_formatted_for_clinical, clinical)
distance_methods <- c("euclidean", "bray", "manhattan", "jaccard", "pearson","spearman")
# PCoA and NMDS (NMDS is computed on ranks of the distance matrix)
for (dist_method in distance_methods) {
compute_pcoa_nmds(TPM_formatted_for_clinical, sample_metadata_df = clinical, distance_method = dist_method)
}
