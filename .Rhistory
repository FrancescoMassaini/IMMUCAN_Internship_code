merged_counts_filtered_forClustering_gene_symbol <- merged_counts_filtered_forClustering %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_filtered_forClustering <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.1)
cat("Number of final genes:", nrow(TPM_filtered_forClustering), "\n Number of starting genes:",  nrow(merged_counts), "\n Difference:", nrow(merged_counts)-nrow(TPM_filtered_forClustering))
compute_distribution(data = TPM_filtered_forClustering, plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
TPM_filtered_forClustering = log2(TPM_filtered_forClustering+1)
colSums(TPM_filtered_forClustering)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id") %>%
replace(is.na(.), "MISSING")
# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical = TPM_filtered_forClustering
colnames(TPM_formatted_for_clinical) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_formatted_for_clinical))
common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical))
TPM_formatted_for_clinical <- TPM_formatted_for_clinical %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
# Ensure to merge in the same order TPM with clinical values
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Compute PCA
pca_result <- FactoMineR::PCA(t(TPM_formatted_for_clinical), scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.85, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
View(pca_result)
# PCA biplot on TPM
# Ensure to merge in the same order TPM with clinical values
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Compute PCA
pca_result <- FactoMineR::PCA(t(TPM_formatted_for_clinical), scale.unit = TRUE, graph = FALSE)
# Ensure to merge in the same order TPM and clinical values
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
View(tmp)
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# write.table(TPM_forDeconv, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt")
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_filtered_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 8, zero_count_percent_threshold = 0.8)
compute_distribution(data = merged_counts_filtered_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_filtered_forClustering_gene_symbol <- merged_counts_filtered_forClustering %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_filtered_forClustering <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.1)
cat("Number of final genes:", nrow(TPM_filtered_forClustering), "\n Number of starting genes:",  nrow(merged_counts), "\n Difference:", nrow(merged_counts)-nrow(TPM_filtered_forClustering))
compute_distribution(data = TPM_filtered_forClustering, plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
TPM_filtered_forClustering = log2(TPM_filtered_forClustering+1)
colSums(TPM_filtered_forClustering)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id") %>%
replace(is.na(.), "MISSING")
# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical = TPM_filtered_forClustering
colnames(TPM_formatted_for_clinical) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_formatted_for_clinical))
common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical))
TPM_formatted_for_clinical <- TPM_formatted_for_clinical %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
View(TPM_formatted_for_clinical)
View(TPM_formatted_for_clinical)
View(clinical)
# Ensure to merge in the same order TPM and clinical values
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
View(tmp)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.85, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_filtered_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.8)
compute_distribution(data = merged_counts_filtered_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_filtered_forClustering_gene_symbol <- merged_counts_filtered_forClustering %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_filtered_forClustering <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.15)
cat("Number of final genes:", nrow(TPM_filtered_forClustering), "\n Number of starting genes:",  nrow(merged_counts), "\n Difference:", nrow(merged_counts)-nrow(TPM_filtered_forClustering))
compute_distribution(data = TPM_filtered_forClustering, plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Ensure clinical patients and BIODICA results are in the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df_NSCLC)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Ensure clinical patients and BIODICA results are in the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df_NSCLC)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df_NSCLC <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Ensure clinical patients and BIODICA results are in the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df_NSCLC)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df_NSCLC = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
metasample_df_NSCLC <- as.matrix(metasample_df_NSCLC)
metagene_df_NSCLC <- as.matrix(metagene_df_NSCLC)
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Plot final SAMPLE heatmap
metasample_df_NSCLC = metasample_df_NSCLC[order(metasample_df_NSCLC[,"IC1"], decreasing = TRUE),]
pheatmap(t(metasample_df_NSCLC), main = "main_title",
annotation_col = clinical,
color = heatmap_colors,
show_colnames = T, show_rownames = T,
fontsize_col = 5, fontsize_row = 5, fontsize = 5, clustering_method = 'complete',
border = NA)
pheatmap(t(metasample_df_NSCLC), main = "main_title",
annotation_col = clinical,
color = heatmap_colors,
show_colnames = T, show_rownames = T,
fontsize_col = 5, fontsize_row = 5, fontsize = 10, clustering_method = 'complete',
border = NA)
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Order most important IC and use the same order for clinical samples
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))
# Ordina in base alla prima componente indipendente (IC1)
order <- order(metasample_df["IC1", ], decreasing = TRUE)
metasample_df <- metasample_df[, order, drop = FALSE]
clinical <- clinical[order, , drop = FALSE]
identical(colnames(metasample_df), rownames(clinical))
# Plot final SAMPLE heatmap
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 5, fontsize = 10, clustering_method = 'complete',
border = NA)
clinical["LUNG-NSCLC2-0584",]
clinical["LUNG-NSCLC2-0648",]
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Chunk 1: Imports
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
# Chunk 2: Functions
source("./Functions.R")
# Chunk 3: Data loading
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Chunk 4: Processing Raw Counts
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# write.table(TPM_forDeconv, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt")
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_filtered_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 12, zero_count_percent_threshold = 0.8)
compute_distribution(data = merged_counts_filtered_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_filtered_forClustering_gene_symbol <- merged_counts_filtered_forClustering %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_filtered_forClustering <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.2)
cat("Number of final genes:", nrow(TPM_filtered_forClustering), "\n Number of starting genes:",  nrow(merged_counts), "\n Difference:", nrow(merged_counts)-nrow(TPM_filtered_forClustering))
compute_distribution(data = TPM_filtered_forClustering, plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
TPM_filtered_forClustering = log2(TPM_filtered_forClustering+1)
colSums(TPM_filtered_forClustering)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical = TPM_filtered_forClustering
colnames(TPM_formatted_for_clinical) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_formatted_for_clinical))
common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical))
TPM_formatted_for_clinical <- TPM_formatted_for_clinical %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
# Save the file in the right format for BIODICA INDIPENDENT COMPONENT ANALYSIS (IDA)
#write.table(TPM_formatted_for_clinical, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica.txt", sep = "\t", row.names = TRUE, header = TRUE)
TPM_forBIODICA = TPM_formatted_for_clinical %>%
rownames_to_column(var = "genes")
write.table(TPM_forBIODICA, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
print(tree)
}
# dev.off()
# PCA biplot on TPM
# Ensure to merge in the same order TPM and clinical values and traspose
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
replace(is.na(.), "MISSING") # Replace NA with missing to show NA values on fviz_pca_biplot
# Compute PCA
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical, scale.unit = TRUE, graph = FALSE)
fviz_eig(pca_result) # Scree plot: explained variance by PC
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
habillage = as.factor(clinical[,feat]),
addEllipses = T, ellipse.level=0.85, palette = "Dark2",
legend.title = feat,
ggtheme = theme_minimal())
print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
# UMAP on TPM
clinical <- clinical %>%
mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA
umap_result <- as.data.frame(umap(TPM_formatted_for_clinical, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")
for (feat in colnames(clinical_umap)[-1]){
col = c("UMAP1", "UMAP2", feat)
umap_ggplot = dplyr::select(umap_result, all_of(col))
colnames(umap_ggplot)[3] = "feat"
umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
geom_point(size = 3) +
labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
theme_minimal() +
labs(color = feat)
print(umap_plot)
}
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Order most important IC and use the same order for clinical samples
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))
# Ordina in base alla prima componente indipendente (IC1)
order <- order(metasample_df["IC1", ], decreasing = TRUE)
metasample_df <- metasample_df[, order, drop = FALSE]
clinical <- clinical[order, , drop = FALSE]
identical(colnames(metasample_df), rownames(clinical))
# Plot final SAMPLE heatmap
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 5, fontsize = 10, clustering_method = 'complete',
border = NA)
# Load MetaSample and MetaGene from BIODICA analysis.
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_ICA/TPM_NSCLC2_Biodica_ica_S.xls", header = TRUE, row.names = 1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]
# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)
# Order most important IC and use the same order for clinical samples
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))
# Ordina in base alla prima componente indipendente (IC1)
order <- order(metasample_df["IC1", ], decreasing = TRUE)
metasample_df <- metasample_df[, order, drop = FALSE]
clinical <- clinical[order, , drop = FALSE]
identical(colnames(metasample_df), rownames(clinical))
# Plot final SAMPLE heatmap
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 5, fontsize = 10, clustering_method = 'complete',
border = NA)
# Plot final SAMPLE heatmap
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = FALSE
show_colnames = T, show_rownames = T,
# Plot final SAMPLE heatmap
pheatmap(metasample_df, main = "",
annotation_col = clinical,
color = heatmap_colors,
cluster_cols = FALSE,
show_colnames = T, show_rownames = T,
fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
border = NA)
