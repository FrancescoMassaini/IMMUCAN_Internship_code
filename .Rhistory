scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 0.5, vjust = 0.5))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations in Mtcars",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 0, vjust = 0.5))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations in Mtcars",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0.5))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations in Mtcars",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 0))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations in Mtcars",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion signatures")
ggsave(filename = paste0(output_folder_deconvolution, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 20, height = 20)
ggsave(filename = paste0(output_folder_deconvolution, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 20, height = 20)
ggsave(filename = paste0(output_folder_deconvolution, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cor(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Deconvoltion Data Loading
input_folder_deconvolution <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/"
output_folder_deconvolution <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/"
txt_input_files_deconvolution <- c("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/03_Deconvolution/all_deconvolutions_NSCLC2_TPM_noCD226_signatureCLLpatient3.txt")
files_names_deconvolution <- gsub(".txt$", "", basename(txt_input_files_deconvolution))
deconv <- read.table(txt_input_files_deconvolution, header = TRUE,  sep = '	', row.names = 1)
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(deconv) <- rownames(deconv) %>%
str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cor(merged_df)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index)
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
formatted_cors(merged_df) %>%
ggplot(aes(measure1, measure2, fill=r, label=round(r_if_sig,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations in Mtcars",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"))
View(high_corr_pairs_Mixed)
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(deconv) <- rownames(deconv) %>%
str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cor(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index)
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
View(high_corr_pairs_Mixed)
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(deconv) <- rownames(deconv) %>%
str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cors(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("Deconvolution Features")
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(deconv) <- rownames(deconv) %>%
str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cors(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("Deconvolution Features")
ggsave(filename = paste0(output_folder_deconvolution, "deconvolution_vs_IF1.png"), plot = last_plot(), width = 20, height = 20)
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF"))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations Deconvolution Features vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("Deconvolution Features")
ggsave(filename = paste0(output_folder_deconvolution, "deconvolution_vs_IF1.png"), plot = last_plot(), width = 20, height = 20)
output_folder_CellTFusion <- "/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/04_CellTFusion/"
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(CellTFusion) <- rownames(CellTFusion) %>%
str_remove_all(pattern = "-RNA-01|-RNA-02|-RNA-04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(CellTFusion)))
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
CellTFusion_common <- CellTFusion[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, CellTFusion_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cors(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "CellTFusion"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "CellTFusion"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_CellTFusion <- filter(high_corr_pairs_filtered, ID1 == "CellTFusion", ID2 == "CellTFusion")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF"))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion Features")
ggsave(filename = paste0(output_folder_CellTFusion, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
sort(Corr)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
sort(x.Corr)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
sort(data.Corr)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
arrange(Corr)
View(high_corr_pairs_Mixed)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
arrange(desc(Corr))
View(high_corr_pairs_Mixed)
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion Features")
high_corr_pairs_CellTFusion <- filter(high_corr_pairs_filtered, ID1 == "CellTFusion", ID2 == "CellTFusion")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
arrange(desc(Corr))
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion Features")
ggsave(filename = paste0(output_folder_CellTFusion, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "CellTFusion")|(ID1 == "CellTFusion" & ID2 == "IF")) %>%
arrange(Corr)
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion Features")
ggsave(filename = paste0(output_folder_CellTFusion, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations CellTFusion vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("CellTFusion Features")
ggsave(filename = paste0(output_folder_CellTFusion, "CellTFusion_vs_IF.png"), plot = last_plot(), width = 10, height = 10)
# loading mIF files and using the same patient names convention for IF and deconvlution results. Deleting also Tumor counts from IF data
IF1 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF1_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF1) <- rownames(IF1) %>%
str_remove_all("-IF1-01")
IF2 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF2_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF2) <- rownames(IF2) %>%
str_remove_all("-IF2-01")
IF3 <- read.csv("/home/francesco.massaini/Desktop/IMMUCAN_data/NSCLC2/01_IF_IMC/IF3_cell_type_fraction.csv", header = 1, row.names = 1)
rownames(IF3) <- rownames(IF3) %>%
str_remove_all("-IF3-01")
rownames(deconv) <- rownames(deconv) %>%
str_remove_all(pattern = ".RNA.01|.RNA.02|.RNA.04")
# Keeping only common patients and subsetting deconv and IF
common_patients <- Reduce(intersect, list(rownames(IF1), rownames(IF2), rownames(IF3), rownames(deconv))) # Redcue beacuse to apply intersect on more sets, you should reduce the common intersection progressively
IF1_common <- IF1[common_patients,]
IF2_common <- IF2[common_patients,]
IF3_common <- IF3[common_patients,]
deconv_common <- deconv[common_patients,]
merged_df <- cbind(IF1_common, IF2_common, IF3_common, deconv_common)
colnames(merged_df) <- make.unique(colnames(merged_df)) # ensure unique colnames to easily access to data
correlation_matrix = cors(merged_df)
corr_mat_adjusted <- correlation_matrix
corr_mat_adjusted[[1]][corr_mat_adjusted[[3]] >= 0.05] <- NA
corr_mat_adjusted <- as.matrix(corr_mat_adjusted[[1]])
corr_mat_adjusted[(corr_mat_adjusted <= 0.6  & corr_mat_adjusted >= -0.6)] <- NA
image(corr_mat_adjusted)
# Further analyse highly correlated features
corr_mat_adjusted[corr_mat_adjusted == 1] <- NA
feature1_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,1])
feature2_index <- as.integer(which(!is.na(corr_mat_adjusted), arr.ind = T)[,2])
mIF <- make.unique(c(colnames(IF1_common), colnames(IF2_common), colnames(IF3_common)))
valid_indices <- feature1_index < feature2_index  # Take only indices which are not symmetric
corr_values <- mapply(function(r, c) corr_mat_adjusted[r, c], feature1_index, feature2_index) # map a function to store each correlation value
high_corr_pairs <- data.frame("ID1" = ifelse(rownames(corr_mat_adjusted)[feature1_index] %in% mIF, "IF", "Deconv"),
"Feature1" = rownames(corr_mat_adjusted)[feature1_index],
"ID2" = ifelse(colnames(corr_mat_adjusted)[feature2_index] %in% mIF, "IF", "Deconv"),
"Feature2" = colnames(corr_mat_adjusted)[feature2_index],
"Corr" = corr_values)
high_corr_pairs_filtered <- high_corr_pairs[valid_indices, ]
# Splitting correlation based on where they come from
high_corr_pairs_IF <- filter(high_corr_pairs_filtered, ID1 == "IF", ID2 == "IF")
high_corr_pairs_Deconv <- filter(high_corr_pairs_filtered, ID1 == "Deconv", ID2 == "Deconv")
high_corr_pairs_Mixed <- filter(high_corr_pairs_filtered, (ID1 == "IF" & ID2 == "Deconv")|(ID1 == "Deconv" & ID2 == "IF")) %>%
arrange(Corr)
ggplot(data = high_corr_pairs_Mixed, aes(Feature1, Feature2, fill=Corr, label=round(Corr,2))) +
geom_tile() +
labs(x = NULL, y = NULL, fill = "Pearson's\nCorrelation", title="Correlations Deconvolution Features vs mIF",
subtitle="Only significant Pearson's correlation coefficients shown") +
scale_fill_gradient2(mid="#FBFEF9",low="#0C6291",high="#A63446", limits=c(-1,1)) +
geom_text() +
theme_classic() +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
theme(text=element_text(family="Roboto"), axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
xlab("mIF") +
ylab("Deconvolution Features")
ggsave(filename = paste0(output_folder_deconvolution, "deconvolution_vs_IF1.png"), plot = last_plot(), width = 20, height = 20)
