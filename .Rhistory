input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version()
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = , use_log = T) # log2(x+1)
# Plots - Distribution
compute_distribution <- function(data, value_type, plot_title, xlab, ylab = "Density", use_log = TRUE) {
# Convert row names to a column
data_with_genes <- data %>%
rownames_to_column(var = "Genes")
# Pivot data to long format
data_long <- pivot_longer(data_with_genes,
cols = -Genes,
names_to = "Patient",
values_to = value_type)
# Calculate log2(value+1) if use_log is TRUE, otherwise use the direct value
plot_expression <- if (use_log) {
aes_string(x = paste0("log2(", value_type, "+1)"))
} else {
aes_string(x = value_type)
}
# Create density plot
plot <- ggplot(data_long, plot_expression) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
return(plot)
}
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = , use_log = T) # log2(x+1)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
compute_distribution(data = TPM, value_type = "TPM", plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_gene_symbol <- merged_counts %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM <- counts_to_TPM(merged_counts_gene_symbol, log = F) # not yet log2 transformed
colSums(TPM)
# write.table(TPM, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt")
# Summary and check TPM
summary(TPM)
colSums(TPM) # NOTE, this doesn't sum up to 1 million anymore because when you convert ENSEMBL IDs to GENE SYMBOLS some genes are lost because of duplicates names
compute_distribution(data = TPM, value_type = "TPM", plot_title = "Distribution of TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)
# Load clinical data
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
column_to_rownames(var = "immucan_id")
# Adapt rownames of TPM to clinical ones
TPM_clinical = TPM
colnames(TPM_clinical) = gsub(pattern = "-FIXT.*",
replacement = "",
x = colnames(TPM_clinical))
common_samples <- intersect(rownames(clinical), colnames(TPM_clinical))
TPM_clinical <- TPM_clinical %>% dplyr::select(all_of(common_samples))
clinical <- clinical[rownames(clinical) %in% common_samples, ]
# Heatmap on TPM, groups and outliers
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data")
# dev.off()
View(merged_counts)
source("./Functions.R")
source("./Functions.R")
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(merged_counts, avg_expr_threshold = 10, zero_count_percent_threshold = 0.9) %>%
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(merged_counts, avg_expr_threshold = 10, zero_count_percent_threshold = 0.9) %>%
filter_low_variance_genes(merged_counts, variance_threshold = 0.5)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9) %>%
filter_low_variance_genes(., variance_threshold = 0.5)
source("./Functions.R")
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9) %>%
filter_low_variance_genes(., variance_threshold = 0.5)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9) %>%
filter_low_variance_genes(., variance_threshold = 0.01)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
merged_counts = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 5, zero_count_percent_threshold = 0.9) %>%
filter_low_variance_genes(., variance_threshold = 0.01)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
compute_distribution(data = merged_counts, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = F) # log2(x+1)
summary(merged_counts)
View(merged_counts)
summary(rowVars(merged_counts))
summary(rowVars(data.frame(merged_counts)))
summary(rowVars(as.matrix(merged_counts)))
rowVars(as.matrix(merged_counts))
summary(rowVars(as.matrix(merged_counts)))
summary(rowVars(as.matrix(merged_counts)))[2]
summary(rowVars(as.matrix(merged_counts)))[[2]]
TPM_forDeconv = merged_counts %>% # Deconvolution methods already take into account low expressed and low variance genes
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# For basic clustering methods we need to start with filtering steps
compute_distribution(data = merged_counts_forClustering, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# For basic clustering methods we need to start with filtering steps
compute_distribution(data = merged_counts_forClustering, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
summary(rowVars(as.matrix(merged_counts)))
rowVars(as.matrix(merged_counts))
as.data.frame(rowVars(as.matrix(merged_counts)))
a = as.data.frame(rowVars(as.matrix(merged_counts)))
View(a)
ggplot(a, aes(x=rowVars(as.matrix(merged_counts)))) +
geom_density() +
theme_bw() +
ggplot(a, aes(x=rowVars(as.matrix(merged_counts)))) +
geom_density() +
theme_bw()
ggplot(a, aes(x=log2(rowVars(as.matrix(merged_counts))))) +
geom_density() +
theme_bw()
ggplot(a, aes(x=log2(1+rowVars(as.matrix(merged_counts))))) +
geom_density() +
theme_bw()
# Calculate the variance for each gene and filter
df = as.data.frame(variance = rowVars(as.matrix(data)))
# Calculate the variance for each gene and filter
data = merged_counts
df = as.data.frame(variance = rowVars(as.matrix(data)))
# Calculate the variance for each gene and filter
data = merged_counts
df = as.data.frame(variance = rowVars(as.matrix(data)))
df = as.data.frame(rowVars(as.matrix(data)))
View(df)
colnames(df) = "variance"
View(df)
# Calculate the variance for each gene and filter
data = merged_counts
df = as.data.frame(rowVars(as.matrix(data)))
colnames(df) = "variance"
df = rownames_to_column(df, var = "genes")
genes = df["genes", "variance" > quantile(df$variance, quantile_treshold)]
quantile_threshold = 0.1
genes = df["genes", "variance" > quantile(df$variance, quantile_treshold)]
quantile_threshold = 0.1
genes = df["genes", "variance" > quantile(df$variance, prob = quantile_treshold)]
quantile_threshold = 0.1
genes = df["genes", "variance" > quantile(df$variance, prob = quantile_threshold)]
genes = df[df$variance > quantile(df$variance, prob = quantile_threshold), "genes"]
View(df)
quantile(df$variance, prob = quantile_threshold)
quantile(df$variance, prob = quantile_threshold)[1]
df$variance > quantile(df$variance, prob = quantile_threshold)
unique(df$variance > quantile(df$variance, prob = quantile_threshold))
which(!(df$variance > quantile(df$variance, prob = quantile_threshold)))
quantile_threshold = 0.01
keep = df[df$variance > quantile(df$variance, prob = quantile_threshold), "genes"]
data = data[keep, ]
quantile_threshold = 0.05
keep = df[df$variance > quantile(df$variance, prob = quantile_threshold), "genes"]
data = data[keep, ]
source("./Functions.R")
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# For basic clustering methods we need to start with filtering steps
compute_distribution(data = merged_counts_forClustering, value_type = "Counts", plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# For basic clustering methods we need to start with filtering steps
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# For basic clustering methods we need to start with filtering steps
merged_counts_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9)
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Convert row names to a column
data = merged_counts_forClustering
plot_title = "Distribution of counts"
xlab = "log2(Counts+1)"
use_log = T
data_with_genes <- data %>%
rownames_to_column(var = "Genes")
# Pivot data to long format
data_long <- pivot_longer(data_with_genes,
cols = -Genes,
names_to = "Patient",
values_to = "Counts")
# Calculate log2(value+1) if use_log is TRUE, otherwise use the direct value
if (use_log) {
# Create density plot
plot <- ggplot(data_long, x=log2(Counts+1)) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
else {
# Convert row names to a column
data = merged_counts_forClustering
plot_title = "Distribution of counts"
xlab = "log2(Counts+1)"
use_log = T
data_with_genes <- data %>%
rownames_to_column(var = "Genes")
# Pivot data to long format
data_long <- pivot_longer(data_with_genes,
cols = -Genes,
names_to = "Patient",
values_to = "Counts")
# Calculate log2(value+1) if use_log is TRUE, otherwise use the direct value
if (use_log) {
# Create density plot
plot <- ggplot(data_long, x=log2(Counts+1)) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
else {
source("./Functions.R")
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Plots - Distribution
compute_distribution <- function(data, plot_title, xlab, ylab = "Density", use_log = TRUE) {
# Convert row names to a column
data_with_genes <- data %>%
rownames_to_column(var = "Genes")
# Pivot data to long format
data_long <- pivot_longer(data_with_genes,
cols = -Genes,
names_to = "Patient",
values_to = "Counts")
# Calculate log2(value+1) if use_log is TRUE, otherwise use the direct value
if (use_log) {
# Create density plot
plot <- ggplot(data_long, x=log2(Counts+1)) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
else {
plot <- ggplot(data_long, aes(x=Counts)) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
return(plot)
}
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# Plots - Distribution
compute_distribution <- function(data, plot_title, xlab, ylab = "Density", use_log = TRUE) {
# Convert row names to a column
data_with_genes <- data %>%
rownames_to_column(var = "Genes")
# Pivot data to long format
data_long <- pivot_longer(data_with_genes,
cols = -Genes,
names_to = "Patient",
values_to = "Counts")
# Calculate log2(value+1) if use_log is TRUE, otherwise use the direct value
if (use_log) {
# Create density plot
plot <- ggplot(data_long, aes(x=log2(Counts+1))) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
else {
plot <- ggplot(data_long, aes(x=Counts)) +
geom_density() +
theme_bw() +
labs(title = plot_title,
x = xlab,
y = ylab)
}
return(plot)
}
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
suppressMessages(library(dplyr))
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
source("./Functions.R")
# Imposta il percorso della cartella
input_folder <- "../IMMUCAN_data/NSCLC2/01_Raw_Counts/star_counts"
output_folder_TPM <- "../IMMUCAN_data/NSCLC2/02_TPM/"
output_folder_TPM_outlier <- "../IMMUCAN_data/NSCLC2/02_Plot_Outliers/"
output_folder_deconvolution <- "../IMMUCAN_data/NSCLC2/03_Deconvolution/Whitout_CD226_and_without_patient3/"
output_folder_CellTFusion <- "../IMMUCAN_data/NSCLC2/04_CellTFusion/Whitout_CD226_and_without_patient3/"
# Ottieni tutti i file .txt nella cartella
txt_input_files <- list.files(path = input_folder, pattern = "\\.txt$", full.names = TRUE)
files_names <- gsub(".txt$", "", basename(txt_input_files))
samples_names = str_split_i(files_names, "_", 1)
# Merging all the patients files removing gene version
merged_counts <- read.delim(txt_input_files[1], header = 0, row.names = 1)
colnames(merged_counts) <- samples_names[1]
for (i in 2:length(txt_input_files)) {
# Leggi il data frame successivo
counts <- read.delim(txt_input_files[i], header = 0, row.names = 1)
colnames(counts) <- samples_names[i]
# Unisci le colonne del nuovo data frame a merged_counts
merged_counts <- cbind(merged_counts, counts)
}
cat("Sum of counts across samples: \n")
colSums(merged_counts) # Not yet normalized to TPM
# Deconvolution methods already take into account low expressed and low variance genes so we can directly compute TPM
TPM_forDeconv = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
EnsemblID_to_GeneSymbol() %>%
counts_to_TPM(., log=T)
# write.table(TPM_forDeconv, "../IMMUCAN_data/NSCLC2/02_TPM/NSCLC2_TPM.txt")
merged_counts_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9)
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 10, zero_count_percent_threshold = 0.9)
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
compute_distribution(data = merged_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
merged_counts_forClustering = merged_counts %>%
filter(!rownames(.) %in% c("__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligned", "__alignment_not_unique")) %>%
remove_gene_version() %>%
filter_low_expr_genes(., avg_expr_threshold = 5, zero_count_percent_threshold = 0.9)
compute_distribution(data = merged_counts_forClustering, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
# filtering out not useful rows and converting to GENE SYMBOLS
merged_counts_forClustering_gene_symbol <- merged_counts_forClustering %>%
EnsemblID_to_GeneSymbol() # here many genes will be deleted due to the duplicated genes found with the conversion to gene symbol
# ADImpute to normalize to TPM
TPM_forClustering <- counts_to_TPM(merged_counts_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
filter_low_variance_genes(., quantile_threshold = 0.05)
cat("Number of final genes:", nrow(TPM_forClustering) )
compute_distribution(data = merged_counts_forClustering_gene_symbol, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
View(TPM_forClustering)
TPM_forClustering = log2(TPM_forClustering+1)
colSums(TPM_forClustering)
