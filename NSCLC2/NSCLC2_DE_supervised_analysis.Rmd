
---
title: "NSCLC2"
author: "Francesco Massaini"
date: "2024-03-28"
output: html_document
editor_options: 
  chunk_output_type: inline
---

# Imports
```{r Imports}
suppressMessages(library(dplyr)) 
suppressMessages(library(tibble))
suppressMessages(library(tidyr))
suppressMessages(library(org.Hs.eg.db)) # Homo sapiens db
suppressMessages(library(stringr))
suppressMessages(library(RColorBrewer)) # for plot
suppressMessages(library(pheatmap)) # for heatmaps
suppressMessages(library(ADImpute)) # This package provides functions to compute TPM
suppressMessages(library(ggplot2))
suppressMessages(library(FactoMineR))
suppressMessages(library(factoextra))
suppressMessages(library(survival))
suppressMessages(library(ranger))
suppressMessages(library(ggfortify))
suppressMessages(library(rlang))
suppressMessages(library(purrr))
suppressMessages(library(rio))
suppressMessages(library(uwot))
suppressMessages(library(DESeq2))
```


# Functions
```{r Functions}
source("./Functions.R")
```

# Data loading and processiong
## Load NSCLC2 data
```{r}
# Expression data
raw_counts = read.delim("../../IMMUCAN_data/NSCLC2/01_Raw_Counts/NSCLC2_all_patients_counts_forDE.txt", sep = "\t", check.names = FALSE)

# Clinical data
clinical = read.csv("../../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_Daniel_relevant_columns.csv", row.names = 1) # Load
```

## making sure the row names in clinical matches to columns names in raw_counts and with the same order (DEseq requirements)
```{r}
colnames(raw_counts) = str_split_i(colnames(raw_counts), pattern = "-FIXT-.*", i = 1) # no issues with multiple samples for each patients because there is only one sample for each patients

clinical = clinical %>%
  filter(rownames(.) %in% colnames(raw_counts)) # select only common patients 

identical(rownames(clinical), colnames(raw_counts)) # identical checks also for the order

```

# pre-filtering: removing rows with low gene counts
```{r}
compute_distribution(data = raw_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
filtered_raw_counts = filter_low_expr_genes(raw_counts, avg_expr_threshold = 12, zero_count_percent_threshold = 0.8)
compute_distribution(data = filtered_raw_counts, plot_title = "Distribution of counts", xlab = "log2(Counts+1)", use_log = T) # log2(x+1)
cat("Number of final genes:", nrow(filtered_raw_counts), "\nInitial number of genes:",  nrow(raw_counts), "\n Difference:", nrow(raw_counts)-nrow(filtered_raw_counts))
```



## Construct a DESeqDataSet object
```{r}
dds = DESeqDataSetFromMatrix(countData = filtered_raw_counts,
                       colData = clinical,
                       design = ~ death) # design specify the column of clinical data to use
dds
```
# set the factor level
```{r}
dds$death <- relevel(dds$death, ref = "Yes")
```


# Run DESeq on the previously created object
```{r}
dds <- DESeq(dds) # run DESeq and saving back results on the same object
res <- results(dds) # saving DESeq results in res

res
# results columns
# baseMean : average of normalized counts
# log2FoldChange : FC of genes compared between conditions     
# lfcSE : standard estimate of logFC 
# stat : wall test values for each genes
# pvalue : pvalue
# padj : padj for multiple testing
```
# Explore Results 
```{r}
summary(res)

res0.01 <- results(dds, alpha = 0.01)
summary(res0.01)
```
# MA plot
```{r}
plotMA(res)
```





# Analizing filtered TPM 
## Sample Heatmap
NOTE: Expression df must be genes as rows and patients as column. Clinical df must be patients as rows and feature as columns 
```{r, fig.width=10, fig.height=10, Heatmap2}
# Load clinical data 
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
  dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, side_localization, gender) %>%
  column_to_rownames(var = "immucan_id") 

# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical = TPM_filtered_forClustering
colnames(TPM_formatted_for_clinical) = gsub(pattern = "-FIXT.*", 
                              replacement = "",
                              x = colnames(TPM_formatted_for_clinical))

common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical))
TPM_formatted_for_clinical <- TPM_formatted_for_clinical %>% dplyr::select(all_of(common_samples))

clinical <- clinical[rownames(clinical) %in% common_samples, ]

# Heatmap on TPM, groups and outliers 
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data") 
# dev.off()

# Save the file in the right format for BIODICA INDIPENDENT COMPONENT ANALYSIS (IDA)
TPM_forBIODICA = TPM_formatted_for_clinical %>%
  rownames_to_column(var = "genes")
# write.table(TPM_forBIODICA, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica_meanDuplGenes.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
```
## Sample Dendrogram
```{r}
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
  tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
  print(tree)
}
# dev.off()
```

## PCA biplot
```{r}
# PCA biplot on TPM

# Ensure to merge in the same order TPM and clinical values and traspose 
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
  replace(is.na(.), "NA") # Replace NA with missing to show NA values on fviz_pca_biplot

# Compute PCA
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical, scale.unit = TRUE, graph = FALSE)  
fviz_eig(pca_result) # Scree plot: explained variance by PC

# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
  p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
                              habillage = as.factor(clinical[,feat]),
                              addEllipses = T, ellipse.level=0.95, palette = "Dark2", 
                              legend.title = feat,
                              ggtheme = theme_minimal())
  print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
```

## Umap 
```{r}
# UMAP on TPM
clinical <- clinical %>% 
  mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA 

umap_result <- as.data.frame(umap(TPM_formatted_for_clinical, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")

for (feat in colnames(clinical_umap)[-1]){
  col = c("UMAP1", "UMAP2", feat)
  umap_ggplot = dplyr::select(umap_result, all_of(col))
  colnames(umap_ggplot)[3] = "feat" 
  umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
    geom_point(size = 3) +
    labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
    theme_minimal() + 
    labs(color = feat)
    print(umap_plot)
}

TPM_formatted_for_clinical = as.data.frame(t(TPM_formatted_for_clinical))
```

## IDA BIODICA Analysis
```{r IDA2}
# Load MetaSample and MetaGene from BIODICA analysis. 
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_ica_S.xls", header = TRUE, row.names = 1)

# Load clinical data 
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
  dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, side_localization, gender) %>%
  column_to_rownames(var = "immucan_id") 

# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]

# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)

# Show results
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))

pheatmap(metasample_df, main = "",
         annotation_col = clinical,
         color = heatmap_colors,
         cluster_cols = TRUE,
         show_colnames = T, show_rownames = T,
         fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
         border = NA)


# Select most important ICs 
chosen_IC = c("IC1", "IC8", "IC14", "IC4", "IC13", "IC16", "IC3")
metasample_df_selected <- metasample_df[chosen_IC, , drop = FALSE]


# Plot final SAMPLE heatmap
pheatmap(metasample_df_selected, main = "",
         annotation_col = clinical,
         color = heatmap_colors,
         cluster_cols = TRUE,
         cluster_rows = TRUE,
         show_colnames = T, show_rownames = T,
         fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
         border = NA)

# Prepare the data
# Convert 'metasample_df' into a long format
long_metasample <- as.data.frame(t(metasample_df)) %>% 
  tibble::rownames_to_column("Sample") %>%
  pivot_longer(-Sample, names_to = "IC", values_to = "Value")

# Generate violin plots for each IC for each clinical variable
clinical_vars = colnames(clinical) # List of clinical variables
ICs = unique(long_metasample$IC)


# Aggregate violin plot for each clinical variable
for (clin_var in clinical_vars) {
  Wrapped_violin_plot_by_clinical_feature(df_long = long_metasample, metadata_df = clinical, metadata_var = clin_var, facet_wrap_var = "IC")
}

# Specific significant violin plot
for (clin_var in clinical_vars) {
  for (IC_value in ICs){
    df = long_metasample %>%
      dplyr::filter(IC == IC_value) %>%
      dplyr::select(Sample, IC, Value)
    
   significant_violin_plot(df_long = df, metadata_df = clinical, metadata_var = clin_var, p_threshold = 0.05, main_title = paste("Significant violin plot for", IC_value))
   }
}
```



# Working on only the most variable genes
```{r Define the most variable genes}
# ADImpute to normalize to TPM
TPM_high_variance_genes <- counts_to_TPM(merged_counts_filtered_forClustering_gene_symbol, log = F) %>% # not yet log2 transformed
  filter_low_variance_genes(., quantile_threshold = 0.75)

cat("Final nomber of genes: ", nrow(TPM_high_variance_genes))

compute_distribution(data = TPM_high_variance_genes, plot_title = "Distribution of high variance genes - TPM", xlab = "log2(TPM+1)", use_log = T) # log2(x+1)

# Finally convert TPM to log2(TPM+1)
TPM_high_variance_genes = log2(TPM_high_variance_genes+1)
```
## Sample Heatmap
NOTE: Expression df must be genes as rows and patients as column. Clinical df must be patients as rows and feature as columns 
```{r, fig.width=10, fig.height=10, Heatmap}
# Load clinical data 
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
  dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score, gender, simple_histology) %>%
  column_to_rownames(var = "immucan_id") 

# Adapt rownames of TPM to clinical ones
TPM_formatted_for_clinical_high_variance = TPM_high_variance_genes
colnames(TPM_formatted_for_clinical_high_variance) = gsub(pattern = "-FIXT.*", 
                              replacement = "",
                              x = colnames(TPM_formatted_for_clinical_high_variance))

common_samples <- intersect(rownames(clinical), colnames(TPM_formatted_for_clinical_high_variance))
TPM_formatted_for_clinical_high_variance <- TPM_formatted_for_clinical_high_variance %>% dplyr::select(all_of(common_samples))

clinical <- clinical[rownames(clinical) %in% common_samples, ]

# Heatmap on TPM, groups and outliers 
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_heatmap.pdf"), width = 16, height = 16)
Compute_Samples_Heatmap(TPM_formatted_for_clinical_high_variance,  sample_feat_df = clinical, main_title = "Heatmap samples vs samples - Euclidian distance matrix on TPM data") 
# dev.off()

# Save the file in the right format for BIODICA INDIPENDENT COMPONENT ANALYSIS (IDA)
TPM_forBIODICA = TPM_formatted_for_clinical_high_variance %>%
  rownames_to_column(var = "genes")
# write.table(TPM_forBIODICA, "/home/francesco.massaini/Projects/BIODICA/data/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE)
```
## Sample Dendrogram
```{r}
# Sample dendrograms, colored by relevant clinical feature
# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_dendrogram.pdf"), width = 16, height = 10)
for (feat in colnames(clinical)){
  tree = Compute_Samples_dendrogram(TPM_formatted_for_clinical_high_variance,  sample_feat_df = clinical, feat_column = feat, main_title = "Sample dendrogram - Euclidian distance matrix on TPM data")
  print(tree)
}
# dev.off()
```
## PCA biplot
```{r}
# PCA biplot on TPM

# Ensure to merge in the same order TPM and clinical values and traspose 
tmp = dfs_same_patients_same_order(TPM_formatted_for_clinical_high_variance, clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
TPM_formatted_for_clinical_high_variance = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]] %>%
  replace(is.na(.), "NA") # Replace NA with missing to show NA values on fviz_pca_biplot

# Compute PCA
pca_result <- FactoMineR::PCA(TPM_formatted_for_clinical_high_variance, scale.unit = TRUE, graph = FALSE)  
fviz_eig(pca_result) # Scree plot: explained variance by PC

# pdf(paste0(output_folder_TPM_outlier, "TPM_samples_PCA.pdf"))
for (feat in colnames(clinical)){
  p = factoextra::fviz_pca_biplot(pca_result, repel = T, select.var = list(contrib = 5), label = "var",
                              habillage = as.factor(clinical[,feat]),
                              addEllipses = T, ellipse.level=0.95, palette = "Dark2", 
                              legend.title = feat,
                              ggtheme = theme_minimal())
  print(p)
}
# repel = T do not overlap the text, select.var = list(contrib = 5) shows only the most 5 variable feature (variables) that contributes to separation. label = var , put label ONLY on the 5 variables
# dev.off()
```
## Umap 
```{r}
# UMAP on TPM
clinical <- clinical %>% 
  mutate(across(everything(), ~ifelse(. == "MISSING", NA, .))) # Restore NA 

umap_result <- as.data.frame(umap(TPM_formatted_for_clinical_high_variance, n_neighbors = 8, min_dist = 0.1, metric = "euclidean")) # t() it's not necessary beacuse TPM has been already transposed
colnames(umap_result) <- c("UMAP1", "UMAP2")
umap_result = rownames_to_column(umap_result, var = "samples")
clinical_umap = rownames_to_column(clinical, var = "samples")
umap_result = left_join(umap_result, clinical_umap, by = "samples")

for (feat in colnames(clinical_umap)[-1]){
  col = c("UMAP1", "UMAP2", feat)
  umap_ggplot = dplyr::select(umap_result, all_of(col))
  colnames(umap_ggplot)[3] = "feat" 
  umap_plot <- ggplot(umap_ggplot, aes(x = UMAP1, y = UMAP2, color = feat)) +
    geom_point(size = 3) +
    labs(title = "UMAP of TPM Data", x = "UMAP1", y = "UMAP2") +
    theme_minimal() + 
    labs(color = feat)
    print(umap_plot)
}

TPM_formatted_for_clinical_high_variance = as.data.frame(t(TPM_formatted_for_clinical_high_variance))
```
## IDA BIODICA Analysis
```{r IDA}
# Load MetaSample and MetaGene from BIODICA analysis. 
metasample_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ica_A.xls", header = TRUE, row.names = 1)
metagene_df <- read.table("/home/francesco.massaini/Projects/BIODICA/work/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ICA/TPM_NSCLC2_Biodica_meanDuplGenes_highly_variable_genes_ica_S.xls", header = TRUE, row.names = 1)

# Load clinical data 
clinical = read.csv("../IMMUCAN_data/NSCLC2/01_Clinical_Data/Daniel/NSCLC2_for_R_update_2024.csv") %>%
  dplyr::select(immucan_id, stage, death, neo_adjuvant_treatment, adjuvant_treatment, simple_histology, long_survivors, TIL_score) %>%
  column_to_rownames(var = "immucan_id") 

# Ensure the starting dfs have the same order
tmp = dfs_same_patients_same_order(expr_df = as.data.frame(t(metasample_df)), sample_feat_df = clinical, expr_patients_on_rows = TRUE, clinical_patients_on_rows = TRUE)
metasample_df = tmp[["expression_data"]]
clinical = tmp[["clinical_data"]]

# Heatmap configuration
heatmap_colors <- colorRampPalette(c("navy", "white", "firebrick"))(100)

# Show results
metasample_df <- t(as.matrix(metasample_df))
identical(colnames(metasample_df), rownames(clinical))

pheatmap(metasample_df, main = "",
         annotation_col = clinical,
         color = heatmap_colors,
         cluster_cols = TRUE,
         show_colnames = T, show_rownames = T,
         fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
         border = NA)

# Select most important ICs 
chosen_IC = c("IC1", "IC2", "IC3", "IC9", "IC14", "IC11", "IC22")
metasample_df_selected <- metasample_df[chosen_IC, , drop = FALSE]


# Plot final SAMPLE heatmap
pheatmap(metasample_df_selected, main = "",
         annotation_col = clinical,
         color = heatmap_colors,
         cluster_cols = TRUE,
         cluster_rows = TRUE,
         show_colnames = T, show_rownames = T,
         fontsize_col = 8, fontsize_row = 8, fontsize = 10, clustering_method = 'complete',
         border = NA)


# Prepare the data
# Convert into a long format
long_metasample <- as.data.frame(t(metasample_df_selected)) %>% 
  tibble::rownames_to_column("Sample") %>%
  pivot_longer(-Sample, names_to = "IC", values_to = "Value")

# Generate violin plots for each IC for each clinical variable
clinical_vars = colnames(clinical) # List of clinical variables
ICs = unique(long_metasample$IC)


# Aggregate violin plot for each clinical variable
for (clin_var in clinical_vars) {
  Wrapped_violin_plot_by_clinical_feature(df_long = long_metasample, metadata_df = clinical, metadata_var = clin_var, facet_wrap_var = "IC")
}

# Specific significant violin plot
for (clin_var in clinical_vars) {
  for (IC_value in ICs){
    df = long_metasample %>%
      dplyr::filter(IC == IC_value) %>%
      dplyr::select(Sample, IC, Value)
    
   significant_violin_plot(df_long = df, metadata_df = clinical, metadata_var = clin_var, p_threshold = 0.05, main_title = paste("Significant violin plot for", IC_value))
   }
}
```